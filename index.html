<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Laboratorio Virtual - Plano Inclinado</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        :root {
            --primary-color: #1a365d;
            --secondary-color: #2d3748;
            --accent-color: #3182ce;
            --light-color: #f7fafc;
            --dark-color: #1a202c;
            --success-color: #38a169;
            --warning-color: #d69e2e;
            --danger-color: #e53e3e;
            --text-color: #2d3748;
            --border-radius: 10px;
            --box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            --transition: all 0.3s ease;
        }
       
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
       
        body {
            background: linear-gradient(135deg, #f5f7fa 0%, #e4edf5 100%);
            color: var(--text-color);
            line-height: 1.6;
            min-height: 100vh;
        }
       
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
       
        header {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 15px;
            border-radius: var(--border-radius);
            margin-bottom: 20px;
            box-shadow: var(--box-shadow);
            text-align: center;
            position: relative;
            overflow: hidden;
        }
       
        header::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, var(--accent-color), var(--success-color));
        }
       
        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
       
        .header-title {
            flex: 1;
        }
       
        h1 {
            font-size: 1.2rem;
            margin-bottom: 5px;
            font-weight: 600;
            letter-spacing: -0.5px;
        }
       
        .subtitle {
            font-size: 0.8rem;
            opacity: 0.85;
            font-weight: 400;
        }
       
        .content {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 25px;
            margin-bottom: 30px;
        }
       
        @media (max-width: 1024px) {
            .content {
                grid-template-columns: 1fr;
            }
        }
       
        .panel {
            background: white;
            border-radius: var(--border-radius);
            padding: 28px;
            box-shadow: var(--box-shadow);
            transition: var(--transition);
            border: 1px solid rgba(0, 0, 0, 0.05);
        }
       
        .panel:hover {
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.12);
        }
       
        .panel h2 {
            margin-bottom: 22px;
            padding-bottom: 12px;
            border-bottom: 1px solid #e2e8f0;
            color: var(--primary-color);
            font-weight: 600;
            font-size: 1.4rem;
            display: flex;
            align-items: center;
        }
       
        .panel h2::before {
            content: "";
            display: inline-block;
            width: 4px;
            height: 22px;
            background: var(--accent-color);
            margin-right: 12px;
            border-radius: 2px;
        }
       
        .tabs {
            display: flex;
            margin-bottom: 22px;
            border-bottom: 1px solid #e2e8f0;
            background: #f8fafc;
            border-radius: 8px 8px 0 0;
            padding: 5px;
        }
       
        .tab {
            padding: 12px 22px;
            cursor: pointer;
            border-radius: 6px;
            transition: var(--transition);
            font-weight: 500;
            flex: 1;
            text-align: center;
            color: var(--secondary-color);
        }
       
        .tab.active {
            background: white;
            color: var(--accent-color);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        }
       
        .tab:hover:not(.active) {
            background: rgba(49, 130, 206, 0.05);
        }
       
        .tab-content {
            display: none;
        }
       
        .tab-content.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }
       
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(5px); }
            to { opacity: 1; transform: translateY(0); }
        }
       
        .input-group {
            margin-bottom: 22px;
        }
       
        label {
            display: block;
            margin-bottom: 10px;
            font-weight: 500;
            color: var(--secondary-color);
            font-size: 0.95rem;
        }
       
        input[type="number"], select {
            width: 100%;
            padding: 14px;
            border: 1px solid #e2e8f0;
            border-radius: var(--border-radius);
            font-size: 1rem;
            transition: var(--transition);
            background: white;
        }
       
        input[type="number"]:focus, select:focus {
            border-color: var(--accent-color);
            outline: none;
            box-shadow: 0 0 0 3px rgba(49, 130, 206, 0.15);
        }
       
        .input-container {
            display: flex;
            align-items: center;
            gap: 12px;
        }
       
        .input-container input {
            flex: 1;
        }
       
        .unit {
            min-width: 45px;
            text-align: center;
            font-weight: 500;
            color: var(--secondary-color);
            background: #f7fafc;
            padding: 10px;
            border-radius: 6px;
            font-size: 0.9rem;
        }
       
        .range-container {
            display: flex;
            align-items: center;
            gap: 12px;
        }
       
        .range-container input[type="range"] {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: #e2e8f0;
            outline: none;
            -webkit-appearance: none;
        }
       
        .range-container input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--accent-color);
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
       
        .range-value {
            min-width: 45px;
            text-align: center;
            font-weight: 600;
            background: #f7fafc;
            padding: 8px 12px;
            border-radius: 6px;
            color: var(--primary-color);
        }
       
        button {
            background: var(--accent-color);
            color: white;
            border: none;
            padding: 14px 22px;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: var(--transition);
            width: 100%;
            margin-top: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
       
        button:hover {
            background: #2c5aa0;
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
        }
       
        .simulation-area {
            display: flex;
            flex-direction: column;
            gap: 25px;
        }
       
        .canvas-container {
            background: white;
            border-radius: var(--border-radius);
            padding: 25px;
            box-shadow: var(--box-shadow);
            flex: 1;
            min-height: 450px;
            display: flex;
            flex-direction: column;
            transition: var(--transition);
            border: 1px solid rgba(0, 0, 0, 0.05);
        }
       
        .canvas-container:hover {
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.12);
        }
       
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            border-radius: var(--border-radius);
            background: #f8fafc;
            border: 1px solid #e2e8f0;
        }
       
        .data-display {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 18px;
            margin-top: 22px;
        }
       
        .data-item {
            background: white;
            padding: 18px;
            border-radius: var(--border-radius);
            text-align: center;
            box-shadow: var(--box-shadow);
            transition: var(--transition);
            border-left: 4px solid var(--accent-color);
        }
       
        .data-item:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.1);
        }
       
        .data-label {
            font-size: 0.9rem;
            color: var(--secondary-color);
            margin-bottom: 8px;
            font-weight: 500;
        }
       
        .data-value {
            font-size: 1.6rem;
            font-weight: 700;
            color: var(--primary-color);
        }
       
        .controls {
            display: flex;
            gap: 12px;
            margin-top: 22px;
        }
       
        .controls button {
            flex: 1;
            margin-top: 0;
        }
       
        .reset-btn {
            background: var(--danger-color);
        }
       
        .reset-btn:hover {
            background: #c53030;
        }
       
        .pause-btn {
            background: var(--warning-color);
        }
       
        .pause-btn:hover {
            background: #b7791f;
        }
       
        .export-btn {
            background: var(--success-color);
        }
       
        .export-btn:hover {
            background: #2f855a;
        }
       
        .pulley-config {
            margin-top: 22px;
            padding-top: 22px;
            border-top: 1px solid #e2e8f0;
        }
       
        .pulley-toggle {
            display: flex;
            align-items: center;
            margin-bottom: 18px;
            background: #f8fafc;
            padding: 15px;
            border-radius: var(--border-radius);
        }
       
        .pulley-toggle input {
            margin-right: 12px;
            width: 20px;
            height: 20px;
            accent-color: var(--accent-color);
        }
       
        .pulley-options {
            padding: 18px;
            background: #f8fafc;
            border-radius: var(--border-radius);
            margin-top: 12px;
            border: 1px solid #e2e8f0;
        }
       
        .history-container {
            background: white;
            border-radius: var(--border-radius);
            padding: 25px;
            box-shadow: var(--box-shadow);
            min-height: 320px;
            transition: var(--transition);
            border: 1px solid rgba(0, 0, 0, 0.05);
        }
       
        .history-container:hover {
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.12);
        }
       
        .history-list {
            max-height: 250px;
            overflow-y: auto;
            margin-top: 15px;
            border: 1px solid #e2e8f0;
            border-radius: var(--border-radius);
            padding: 10px;
        }
       
        .history-item {
            background: #f8fafc;
            padding: 15px;
            border-radius: var(--border-radius);
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-left: 4px solid var(--accent-color);
            transition: var(--transition);
        }
       
        .history-item:hover {
            background: #edf2f7;
            transform: translateX(5px);
        }
       
        .history-details {
            flex: 1;
        }
       
        .history-title {
            font-weight: 600;
            color: var(--primary-color);
            margin-bottom: 5px;
        }
       
        .history-params {
            font-size: 0.85rem;
            color: var(--secondary-color);
        }
       
        .history-date {
            font-size: 0.8rem;
            color: var(--secondary-color);
            margin-top: 3px;
        }
       
        .history-actions {
            display: flex;
            gap: 8px;
        }
       
        .history-btn-small {
            background: var(--accent-color);
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: var(--transition);
        }
       
        .history-btn-small:hover {
            background: #2c5aa0;
        }
       
        .history-btn-small.delete {
            background: var(--danger-color);
        }
       
        .history-btn-small.delete:hover {
            background: #c53030;
        }
       
        .empty-history {
            text-align: center;
            padding: 30px;
            color: var(--secondary-color);
            font-style: italic;
        }
       
        footer {
            text-align: center;
            padding: 25px;
            margin-top: 35px;
            background: white;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            font-size: 0.95rem;
            color: var(--secondary-color);
            border-top: 4px solid var(--accent-color);
        }
       
        .info-panel {
            background: white;
            border-radius: var(--border-radius);
            padding: 28px;
            box-shadow: var(--box-shadow);
            margin-top: 25px;
            transition: var(--transition);
            border: 1px solid rgba(0, 0, 0, 0.05);
        }
       
        .info-panel:hover {
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.12);
        }
       
        .info-panel h2 {
            margin-bottom: 18px;
            color: var(--primary-color);
            font-weight: 600;
            font-size: 1.4rem;
            display: flex;
            align-items: center;
        }
       
        .info-panel h2::before {
            content: "";
            display: inline-block;
            width: 4px;
            height: 22px;
            background: var(--accent-color);
            margin-right: 12px;
            border-radius: 2px;
        }
       
        .formula {
            background: #f8fafc;
            padding: 18px;
            border-radius: var(--border-radius);
            margin: 18px 0;
            font-family: 'Courier New', monospace;
            text-align: center;
            border-left: 4px solid var(--accent-color);
            font-weight: 600;
            color: var(--primary-color);
        }
       
        .variable {
            font-style: italic;
            color: var(--accent-color);
            font-weight: 500;
        }
       
        .theory-content {
            line-height: 1.8;
        }
       
        .theory-content p {
            margin-bottom: 18px;
        }
       
        .validation-message {
            color: var(--danger-color);
            font-size: 0.9rem;
            margin-top: 8px;
            display: none;
            font-weight: 500;
        }
       
        .icon {
            width: 18px;
            height: 18px;
            fill: currentColor;
        }
       
        /* Estilos para el sistema de notificaciones */
        .notification-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            max-width: 350px;
        }
       
        .notification {
            background: white;
            border-radius: var(--border-radius);
            padding: 15px;
            margin-bottom: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            border-left: 4px solid var(--accent-color);
            display: flex;
            align-items: flex-start;
            animation: slideIn 0.3s ease;
        }
       
        .notification-icon {
            margin-right: 10px;
            font-size: 1.2rem;
        }
       
        .notification-content {
            flex: 1;
        }
       
        .notification-title {
            font-weight: 600;
            margin-bottom: 5px;
            color: var(--primary-color);
        }
       
        .notification-message {
            font-size: 0.9rem;
            color: var(--secondary-color);
            line-height: 1.4;
        }
       
        .notification-close {
            background: none;
            border: none;
            font-size: 1.2rem;
            cursor: pointer;
            color: var(--secondary-color);
            padding: 0;
            margin: 0;
            width: auto;
        }
       
        .notification-close:hover {
            color: var(--danger-color);
            transform: none;
            box-shadow: none;
        }
       
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(100%);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
       
        /* Estilos para la sección de resultados */
        .results-container {
            background: white;
            border-radius: var(--border-radius);
            padding: 25px;
            box-shadow: var(--box-shadow);
            margin-top: 25px;
            transition: var(--transition);
            border: 1px solid rgba(0, 0, 0, 0.05);
        }
       
        .results-container:hover {
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.12);
        }
       
        .results-explanation {
            background: #f8fafc;
            padding: 15px;
            border-radius: var(--border-radius);
            margin-top: 15px;
            border-left: 4px solid var(--success-color);
        }
       
        .results-explanation h4 {
            margin-bottom: 10px;
            color: var(--primary-color);
        }
       
        .results-explanation p {
            margin-bottom: 10px;
            font-size: 0.9rem;
        }
       
        /* Estilos para la masa objetivo */
        .target-mass-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 15px;
            padding: 10px;
            border-radius: var(--border-radius);
            background: #f8fafc;
            border: 1px solid #e2e8f0;
        }
       
        .target-mass-label {
            font-weight: 500;
            color: var(--secondary-color);
        }
       
        .target-mass-value {
            font-weight: 600;
            color: var(--primary-color);
        }
       
        .target-mass-status {
            margin-left: auto;
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 500;
        }
       
        .target-mass-achieved {
            background: var(--success-color);
            color: white;
        }
       
        .target-mass-not-achieved {
            background: var(--warning-color);
            color: white;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="header-content">
                <div class="header-title">
                    <h1>Laboratorio Virtual: Plano Inclinado</h1>
                    <p class="subtitle">Simulador interactivo para el estudio de la física del movimiento</p>
                </div>
            </div>
        </header>
       
        <div class="content">
            <div class="panel">
                <h2>Configuración del Experimento</h2>
               
                <div class="tabs">
                    <div class="tab active" data-tab="basic">Básico</div>
                    <div class="tab" data-tab="pulley">Poleas</div>
                </div>
               
                <div class="tab-content active" id="basic-tab">
                    <div class="input-group">
                        <label for="mass-input">Masa del objeto (M)</label>
                        <div class="input-container">
                            <input type="number" id="mass-input" min="0.1" value="5" step="0.1">
                            <span class="unit">Kg</span>
                        </div>
                        <div class="validation-message" id="mass-validation"></div>
                    </div>
                   
                    <div class="input-group">
                        <label for="target-mass-input">Masa objetivo</label>
                        <div class="input-container">
                            <input type="number" id="target-mass-input" min="0.1" value="7" step="0.1">
                            <span class="unit">Kg</span>
                        </div>
                    </div>
                   
                    <div class="input-group">
                        <label for="angle-input">Ángulo del plano (θ)</label>
                        <div class="range-container">
                            <input type="range" id="angle-range" min="1" max="90" value="30" step="1">
                            <span class="range-value" id="angle-value">30°</span>
                        </div>
                        <input type="number" id="angle-input" min="1" max="90" value="30" step="1" style="display: none;">
                    </div>
                   
                    <div class="input-group">
                        <label for="friction-input">Coeficiente de fricción (μ)</label>
                        <div class="range-container">
                            <input type="range" id="friction-range" min="0" max="1" value="0.1" step="0.01">
                            <span class="range-value" id="friction-value">0.10</span>
                        </div>
                        <input type="number" id="friction-input" min="0" max="1" value="0.1" step="0.01" style="display: none;">
                    </div>
                   
                    <div class="input-group">
                        <label for="length-input">Longitud del plano (L)</label>
                        <div class="input-container">
                            <input type="number" id="length-input" min="1" value="8" step="0.5">
                            <span class="unit">M</span>
                        </div>
                    </div>
                   
                    <div class="input-group">
                        <label for="gravity-input">Gravedad (g)</label>
                        <div class="input-container">
                            <input type="number" id="gravity-input" value="9.8" min="1" step="0.1">
                            <span class="unit">M/s²</span>
                        </div>
                    </div>
                </div>
               
                <div class="tab-content" id="pulley-tab">
                    <div class="input-group">
                        <label for="mass-input-pulley">Masa del objeto (M)</label>
                        <div class="input-container">
                            <input type="number" id="mass-input-pulley" min="0.1" value="5" step="0.1">
                            <span class="unit">Kg</span>
                        </div>
                        <div class="validation-message" id="mass-validation-pulley"></div>
                    </div>
                   
                    <div class="input-group">
                        <label for="target-mass-input-pulley">Masa objetivo</label>
                        <div class="input-container">
                            <input type="number" id="target-mass-input-pulley" min="0.1" value="7" step="0.1">
                            <span class="unit">Kg</span>
                        </div>
                    </div>
                   
                    <div class="input-group">
                        <label for="counter-mass-input">Masa contrapeso (M₂)</label>
                        <div class="input-container">
                            <input type="number" id="counter-mass-input" min="0.1" value="3" step="0.1">
                            <span class="unit">kg</span>
                        </div>
                        <div class="validation-message" id="counter-mass-validation"></div>
                    </div>
                   
                    <div class="input-group">
                        <label for="angle-input-pulley">Ángulo del plano (θ)</label>
                        <div class="range-container">
                            <input type="range" id="angle-range-pulley" min="1" max="90" value="30" step="1">
                            <span class="range-value" id="angle-value-pulley">30°</span>
                        </div>
                        <input type="number" id="angle-input-pulley" min="1" max="90" value="30" step="1" style="display: none;">
                    </div>
                   
                    <div class="input-group">
                        <label for="friction-input-pulley">Coeficiente de fricción (μ)</label>
                        <div class="range-container">
                            <input type="range" id="friction-range-pulley" min="0" max="1" value="0.1" step="0.01">
                            <span class="range-value" id="friction-value-pulley">0.10</span>
                        </div>
                        <input type="number" id="friction-input-pulley" min="0" max="1" value="0.1" step="0.01" style="display: none;">
                    </div>
                   
                    <div class="input-group">
                        <label for="length-input-pulley">Longitud del plano (L)</label>
                        <div class="input-container">
                            <input type="number" id="length-input-pulley" min="1" value="8" step="0.5">
                            <span class="unit">M</span>
                        </div>
                    </div>
                   
                    <div class="input-group">
                        <label for="gravity-input-pulley">Gravedad (g)</label>
                        <div class="input-container">
                            <input type="number" id="gravity-input-pulley" value="9.8" min="1" step="0.1">
                            <span class="unit">M/s²</span>
                        </div>
                    </div>
                </div>
               
                <button id="start-btn">
                    <svg class="icon" viewBox="0 0 24 24">
                        <path d="M8 5v14l11-7z"/>
                    </svg>
                    Iniciar Simulación
                </button>
                <button id="save-config-btn" style="background: var(--success-color);">
                    <svg class="icon" viewBox="0 0 24 24">
                        <path d="M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7l-4-4zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm3-10H5V5h10v4z"/>
                    </svg>
                    Guardar Configuración
                </button>
                <button id="reset-btn" class="reset-btn">
                    <svg class="icon" viewBox="0 0 24 24">
                        <path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/>
                    </svg>
                    Reiniciar
                </button>
            </div>
           
            <div class="simulation-area">
                <div class="canvas-container">
                    <h2>Visualización del Experimento</h2>
                    <canvas id="simulation-canvas"></canvas>
                    <div class="target-mass-indicator" id="target-mass-indicator">
                        <div class="target-mass-label">Masa objetivo:</div>
                        <div class="target-mass-value" id="target-mass-value">7.0 kg</div>
                        <div class="target-mass-status target-mass-not-achieved" id="target-mass-status">No alcanzada</div>
                    </div>
                </div>
               
                <div class="data-display">
                    <div class="data-item">
                        <div class="data-label">Tiempo</div>
                        <div class="data-value" id="time-value">0.00 s</div>
                    </div>
                    <div class="data-item">
                        <div class="data-label">Posición</div>
                        <div class="data-value" id="position-value">0.00 M</div>
                    </div>
                    <div class="data-item">
                        <div class="data-label">Velocidad</div>
                        <div class="data-value" id="velocity-value">0.00 M/s</div>
                    </div>
                    <div class="data-item">
                        <div class="data-label">Aceleración</div>
                        <div class="data-value" id="acceleration-value">0.00 M/s²</div>
                    </div>
                    <div class="data-item">
                        <div class="data-label">Fuerza Net</div>
                        <div class="data-value" id="force-value">0.00 N</div>
                    </div>
                    <div class="data-item">
                        <div class="data-label">Energía</div>
                        <div class="data-value" id="energy-value">0.00 J</div>
                    </div>
                </div>
               
                <div class="controls">
                    <button id="pause-btn" class="pause-btn">
                        <svg class="icon" viewBox="0 0 24 24">
                            <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>
                        </svg>
                        Pausar
                    </button>
                    <button id="export-btn" class="export-btn">
                        <svg class="icon" viewBox="0 0 24 24">
                            <path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/>
                        </svg>
                        Exportar Datos
                    </button>
                </div>
               
                <div class="history-container">
                    <h2>Historial de Configuraciones</h2>
                    <div class="history-list" id="history-list">
                        <div class="empty-history" id="empty-history">No hay configuraciones guardadas. Guarda una configuración para verla aquí.</div>
                    </div>
                </div>
            </div>
        </div>
       
        <div class="results-container">
            <h2>Resultados y Explicación del Sistema</h2>
            <div class="results-explanation">
                <h4>Análisis del Movimiento</h4>
                <p id="movement-analysis">El sistema está en reposo. Inicie la simulación para ver el análisis del movimiento.</p>
                <h4>Comportamiento del Sistema</h4>
                <p id="system-behavior">El objeto permanecerá en reposo o se moverá dependiendo de la relación entre la fuerza gravitatoria paralela al plano y la fuerza de fricción.</p>
                <h4>Explicación del Desplazamiento</h4>
                <p id="displacement-explanation">El desplazamiento del objeto está determinado por la fuerza neta que actúa sobre él.</p>
            </div>
        </div>
       
        <div class="info-panel">
            <h2>Fundamentos Teóricos</h2>
            <div class="tabs">
                <div class="tab active" data-tab="theory">Teoría</div>
                <div class="tab" data-tab="formulas">Fórmulas</div>
                <div class="tab" data-tab="instructions">Instrucciones</div>
            </div>
            <div class="tab-content active" id="theory-tab">
                <div class="theory-content">
                    <p>Un plano inclinado es una superficie plana que forma un ángulo agudo con la horizontal.
                    Se utiliza para elevar cuerpos a una cierta altura con una fuerza menor que el peso del cuerpo.</p>
                    <p>Las fuerzas que actúan sobre un objeto en un plano inclinado son:</p>
                    <ul>
                        <li><span class="variable">Fuerza Gravitatoria (Peso) (<span class="variable">P</span>):</span> Dirigida verticalmente hacia abajo, se descompone en una componente paralela al plano (<span class="variable">Pₓ = mg sen θ</span>) y una componente normal al plano (<span class="variable">Pᵧ = mg cos θ</span>).</li>
                        <li><span class="variable">Fuerza Normal (<span class="variable">N</span>):</span> Perpendicular al plano inclinado, equilibrando la componente normal del peso.</li>
                        <li><span class="variable">Fuerza de Fricción (<span class="variable">f</span>):</span> Paralela al plano, opuesta al movimiento (o al intento de movimiento). Se calcula como <span class="variable">f = μN</span>.</li>
                        <li><span class="variable">Tensión (<span class="variable">T</span>):</span> Solo presente en el sistema con polea, actuando paralelamente al plano y conectando la masa <span class="variable">M</span> con la masa contrapeso <span class="variable">M₂</span>.</li>
                    </ul>
                    <p>La segunda ley de Newton establece que la aceleración del objeto es directamente proporcional a la fuerza neta que actúa sobre él (<span class="variable">F_neta = ma</span>).</p>
                </div>
            </div>
            <div class="tab-content" id="formulas-tab">
                <div class="formula">
                    <p>Fuerza Neta (Sistema Básico):</p>
                    <p><span class="variable">F_neta</span> = <span class="variable">ma</span> = <span class="variable">mg sen θ - μmg cos θ</span></p>
                </div>
                <div class="formula">
                    <p>Aceleración (Sistema Básico):</p>
                    <p><span class="variable">a</span> = <span class="variable">g (sen θ - μ cos θ)</span></p>
                </div>
                <div class="formula">
                    <p>Fuerza Neta (Sistema con Polea):</p>
                    <p><span class="variable">F_neta</span> = (<span class="variable">M</span> + <span class="variable">M₂</span>) <span class="variable">a</span> = <span class="variable">mg sen θ - f_k - T</span></p>
                </div>
                <div class="formula">
                    <p>Tensión (Sistema con Polea):</p>
                    <p><span class="variable">T</span> = <span class="variable">M₂g - M₂a</span></p>
                </div>
            </div>
            <div class="tab-content" id="instructions-tab">
                <div class="theory-content">
                    <p>Instrucciones del sistema:</p>
                    <ul>
                        <li><strong>Primer paso:</strong> Seleccionar el sistema que desee utilzar (Básico o con polea).</li>
                        <li><strong>Segundo paso:</strong> Insertar datos correspondientes al sistema seleccionado y apretar el boton de iniciar simulación.</li>
                        <li><strong>Tercer paso:</strong> Al detenerse, se puede utilizar la opción reiniciar o exportar datos, al exportarlos se entregará un documento.</li>
                        <li><strong>Nueva función:</strong> Puede guardar configuraciones para usarlas posteriormente desde el panel de historial.</li>
                        <li><strong>Masa objetivo:</strong> Establezca una masa objetivo para verificar si el objeto alcanza esa masa durante la simulación.</li>
                    </ul>
                </div>
            </div>
        </div>
       
        <footer>
            <p>Laboratorio Virtual de Física - Simulador de Plano Inclinado con Poleas y sin poleas</p>
            <p>© 2023 - Departamento de Física - Universidad Virtual</p>
        </footer>
    </div>
   
    <div class="notification-container" id="notification-container"></div>
   
    <script>
        // Elementos del DOM
        const canvas = document.getElementById('simulation-canvas');
        const ctx = canvas.getContext('2d');
       
        // Inputs numéricos
        const massInput = document.getElementById('mass-input');
        const targetMassInput = document.getElementById('target-mass-input');
        const angleInput = document.getElementById('angle-input');
        const angleRange = document.getElementById('angle-range');
        const angleValue = document.getElementById('angle-value');
        const frictionInput = document.getElementById('friction-input');
        const frictionRange = document.getElementById('friction-range');
        const frictionValue = document.getElementById('friction-value');
        const lengthInput = document.getElementById('length-input');
        const gravityInput = document.getElementById('gravity-input');
       
        // Inputs de la pestaña Poleas
        const massInputPulley = document.getElementById('mass-input-pulley');
        const targetMassInputPulley = document.getElementById('target-mass-input-pulley');
        const angleInputPulley = document.getElementById('angle-input-pulley');
        const angleRangePulley = document.getElementById('angle-range-pulley');
        const angleValuePulley = document.getElementById('angle-value-pulley');
        const frictionInputPulley = document.getElementById('friction-input-pulley');
        const frictionRangePulley = document.getElementById('friction-range-pulley');
        const frictionValuePulley = document.getElementById('friction-value-pulley');
        const lengthInputPulley = document.getElementById('length-input-pulley');
        const gravityInputPulley = document.getElementById('gravity-input-pulley');
        const counterMassInput = document.getElementById('counter-mass-input');
       
        // Elementos de la masa objetivo
        const targetMassValue = document.getElementById('target-mass-value');
        const targetMassStatus = document.getElementById('target-mass-status');
        const targetMassIndicator = document.getElementById('target-mass-indicator');
       
        // Botones y outputs
        const startBtn = document.getElementById('start-btn');
        const resetBtn = document.getElementById('reset-btn');
        const pauseBtn = document.getElementById('pause-btn');
        const exportBtn = document.getElementById('export-btn');
        const saveConfigBtn = document.getElementById('save-config-btn');
        const historyList = document.getElementById('history-list');
        const emptyHistory = document.getElementById('empty-history');
       
        const timeValue = document.getElementById('time-value');
        const positionValue = document.getElementById('position-value');
        const velocityValue = document.getElementById('velocity-value');
        const accelerationValue = document.getElementById('acceleration-value');
        const forceValue = document.getElementById('force-value');
        const energyValue = document.getElementById('energy-value');
       
        const massValidation = document.getElementById('mass-validation');
        const counterMassValidation = document.getElementById('counter-mass-validation');
       
        const movementAnalysis = document.getElementById('movement-analysis');
        const systemBehavior = document.getElementById('system-behavior');
        const displacementExplanation = document.getElementById('displacement-explanation');
       
        // Variables de simulación
        let isRunning = false;
        let isPaused = false;
        let animationId;
        let currentTime = 0;
        let position = 0; // Posición a lo largo del plano (0 = inicio, length = final)
        let velocity = 0;
        let acceleration = 0;
        let energy = 0;
        let netForce = 0;
        const deltaTime = 0.016; // Aproximadamente 60 FPS
        let simulationData = [];
       
        // Parámetros iniciales
        let mass = parseFloat(massInput.value);
        let targetMass = parseFloat(targetMassInput.value);
        let angle = parseFloat(angleInput.value);
        let friction = parseFloat(frictionInput.value);
        let length = parseFloat(lengthInput.value);
        let gravity = parseFloat(gravityInput.value);
        let usePulley = false;
        let pulleyConfig = { counterMass: parseFloat(counterMassInput.value) };
        let targetMassAchieved = false;
       
        // Variables para controlar notificaciones
        let angleChanged = false;
        let frictionChanged = false;

        // --- CONSTANTES DE DIBUJO ---
        const massWidth = 40; // Ancho del bloque
        const massHeight = 25; // Alto del bloque
        const massColor = 'rgba(211, 211, 211, 0.9)'; // Gris claro
        const massBorderColor = '#333'; // Gris oscuro para el borde
        const massCenterColor = '#e53e3e'; // Rojo para el centro de masa
        const targetMassColor = '#3182ce'; // Azul para la masa objetivo
        const forceScale = 50; // Escala para la longitud de los vectores de fuerza
        // --- FIN CONSTANTES DE DIBUJO ---
       
        // Historial de configuraciones
        let configHistory = JSON.parse(localStorage.getItem('inclinedPlaneHistory')) || [];
        // Inicializar el historial
        renderHistory();
       
        // Función para mostrar notificaciones
        function showNotification(title, message, type = 'info') {
            const notificationContainer = document.getElementById('notification-container');
            const notification = document.createElement('div');
            notification.className = 'notification';
            let icon = 'ℹ️';
            if (type === 'warning') icon = '⚠️';
            if (type === 'error') icon = '❌';
            if (type === 'success') icon = '✅';
           
            notification.innerHTML = `
                <div class="notification-icon">${icon}</div>
                <div class="notification-content">
                    <div class="notification-title">${title}</div>
                    <div class="notification-message">${message}</div>
                </div>
                <button class="notification-close">&times;</button>
            `;
            notificationContainer.appendChild(notification);
           
            // Cerrar notificación al hacer clic en la X
            notification.querySelector('.notification-close').addEventListener('click', function() {
                notification.remove();
            });
           
            // Auto-eliminar después de 5 segundos
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.remove();
                }
            }, 5000);
        }
       
        // Función para actualizar la sección de resultados
        function updateResultsExplanation() {
            const angleRad = angle * Math.PI / 180;
            const gravitationalForce = mass * gravity * Math.sin(angleRad);
            const normalForce = mass * gravity * Math.cos(angleRad);
            const frictionForce = friction * normalForce;
           
            let netForceValue;
            let acc;
           
            if (!usePulley) {
                // Sistema básico
                netForceValue = gravitationalForce - frictionForce;
                acc = netForceValue / mass;
               
                // Análisis del movimiento
                if (Math.abs(gravitationalForce) <= frictionForce && velocity === 0) {
                    movementAnalysis.textContent = `El objeto está en reposo. La fuerza neta es cero, ya que la componente gravitatoria paralela (${gravitationalForce.toFixed(2)} N) es superada por la fuerza de fricción estática.`;
                    acc = 0;
                    displacementExplanation.textContent = `El objeto no se moverá a menos que se aplique una fuerza externa o se cambien los parámetros (ángulo, fricción).`;
                } else if (netForceValue > 0) {
                    movementAnalysis.textContent = `El objeto está acelerando hacia abajo del plano con una aceleración constante de ${acc.toFixed(2)} m/s².`;
                    displacementExplanation.textContent = `La fuerza neta de ${netForceValue.toFixed(2)} N provoca un movimiento acelerado hacia abajo, recorriendo ${length.toFixed(2)} M.`;
                } else {
                    movementAnalysis.textContent = `El objeto se moverá con velocidad constante o permanecerá en reposo. Aceleración: ${acc.toFixed(2)} m/s².`;
                    displacementExplanation.textContent = `El objeto se moverá con velocidad constante o está en reposo. No hay aceleración neta significativa para un movimiento iniciado.`;
                }
               
            } else {
                // Sistema con polea
                const counterWeightForce = pulleyConfig.counterMass * gravity;
                const drivingForce = gravitationalForce - counterWeightForce;
               
                let frictionDirectionSign = -Math.sign(drivingForce);
                if(drivingForce === 0) frictionDirectionSign = -1; // Default: opposes Px if balanced
               
                if (Math.abs(drivingForce) > frictionForce) {
                    // Hay movimiento
                    netForceValue = drivingForce + (frictionDirectionSign * frictionForce);
                    acc = netForceValue / (mass + pulleyConfig.counterMass);
                } else {
                    // Estático
                    netForceValue = 0;
                    acc = 0;
                }
               
                if (Math.abs(netForceValue) <= 0.01 && velocity === 0) {
                    movementAnalysis.textContent = `El sistema está en equilibrio o reposo. La fuerza neta es casi cero.`;
                    displacementExplanation.textContent = `El sistema no tiene una fuerza neta significativa para iniciar el movimiento.`;
                } else if (netForceValue > 0) {
                    movementAnalysis.textContent = `El objeto (M) acelera hacia abajo del plano con ${acc.toFixed(2)} m/s².`;
                    displacementExplanation.textContent = `La componente gravitatoria paralela domina la fricción y el contrapeso, causando una aceleración positiva.`;
                } else {
                    // netForceValue < 0: el contrapeso y/o fricción son mayores
                    movementAnalysis.textContent = `El contrapeso (M₂) es más pesado y el objeto (M) acelera hacia arriba del plano con ${Math.abs(acc).toFixed(2)} m/s².`;
                    displacementExplanation.textContent = `El contrapeso y la fricción dominan la componente gravitatoria paralela. El sistema se mueve hacia el contrapeso.`;
                }
            }
           
            // Comportamiento del sistema (Común)
            if (acc > 0) {
                systemBehavior.textContent = `El objeto acelerará hacia abajo del plano. La fuerza neta es positiva.`;
            } else if (acc < 0) {
                systemBehavior.textContent = `El objeto acelerará hacia arriba del plano (si hay polea) o desacelerará. La fuerza neta es negativa.`;
            } else {
                systemBehavior.textContent = `El objeto permanecerá en reposo o se moverá con velocidad constante. La fuerza neta es cero.`;
            }
           
            // Explicación del desplazamiento
            if (acc > 0) {
                displacementExplanation.textContent = `El objeto está acelerando hacia abajo del plano con una aceleración de ${acc.toFixed(2)} m/s².
                La velocidad aumenta con el tiempo.`;
            } else if (acc < 0) {
                displacementExplanation.textContent = `El objeto está desacelerando (aceleración negativa de ${acc.toFixed(2)} m/s²).
                La velocidad disminuye con el tiempo.`;
            } else {
                displacementExplanation.textContent = `El objeto se mueve con velocidad constante o está en reposo.
                No hay aceleración neta.`;
            }
           
            // Actualizar indicador de masa objetivo
            updateTargetMassIndicator();
        }
       
        // Función para actualizar el indicador de masa objetivo
        function updateTargetMassIndicator() {
            targetMassValue.textContent = `${targetMass.toFixed(1)} kg`;
           
            // Verificar si se alcanzó la masa objetivo
            if (mass >= targetMass && !targetMassAchieved) {
                targetMassAchieved = true;
                targetMassStatus.textContent = "Alcanzada";
                targetMassStatus.className = "target-mass-status target-mass-achieved";
                showNotification('Masa Objetivo Alcanzada', `¡La masa del objeto (${mass.toFixed(1)} kg) ha alcanzado o superado la masa objetivo (${targetMass.toFixed(1)} kg)!`, 'success');
            } else if (mass < targetMass) {
                targetMassAchieved = false;
                targetMassStatus.textContent = "No alcanzada";
                targetMassStatus.className = "target-mass-status target-mass-not-achieved";
            }
        }
       
        // Guardar configuración actual
        saveConfigBtn.addEventListener('click', function() {
            const configName = prompt("Ingrese un nombre para esta configuración:", `Configuración ${new Date().toLocaleTimeString()}`);
            if (configName) {
                const config = {
                    id: Date.now(),
                    name: configName,
                    timestamp: new Date().toISOString(),
                    params: {
                        mass: mass,
                        targetMass: targetMass,
                        angle: angle,
                        friction: friction,
                        length: length,
                        gravity: gravity,
                        usePulley: usePulley,
                        pulleyConfig: {...pulleyConfig}
                    }
                };
                // Agregar al inicio del array
                configHistory.unshift(config);
                // Limitar a 10 configuraciones
                if (configHistory.length > 10) {
                    configHistory = configHistory.slice(0, 10);
                }
                // Guardar en localStorage
                localStorage.setItem('inclinedPlaneHistory', JSON.stringify(configHistory));
                // Actualizar vista
                renderHistory();
                showNotification('Configuración Guardada', `La configuración "${configName}" se ha guardado correctamente.`, 'success');
            }
        });
       
        // Renderizar historial
        function renderHistory() {
            if (configHistory.length === 0) {
                emptyHistory.style.display = 'block';
                historyList.innerHTML = '';
                historyList.appendChild(emptyHistory);
                return;
            }
           
            emptyHistory.style.display = 'none';
            historyList.innerHTML = '';
            configHistory.forEach(config => {
                const item = document.createElement('div');
                item.className = 'history-item';
                const date = new Date(config.timestamp);
                const dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
               
                let paramsText = `Masa: ${config.params.mass}kg, Objetivo: ${config.params.targetMass}kg, Ángulo: ${config.params.angle}°, Fricción: ${config.params.friction}`;
                if (config.params.usePulley) {
                    paramsText += `, Contrapeso: ${config.params.pulleyConfig.counterMass}kg (Polea)`;
                } else {
                    paramsText += ` (Básico)`;
                }
               
                item.innerHTML = `
                    <div class="history-details">
                        <div class="history-title">${config.name}</div>
                        <div class="history-params">${paramsText}</div>
                        <div class="history-date">${dateStr}</div>
                    </div>
                    <div class="history-actions">
                        <button class="history-btn-small" onclick="loadConfig(${config.id})">Cargar</button>
                        <button class="history-btn-small delete" onclick="deleteConfig(${config.id})">Eliminar</button>
                    </div>
                `;
                historyList.appendChild(item);
            });
        }
       
        // Cargar configuración
        window.loadConfig = function(id) {
            const config = configHistory.find(c => c.id === id);
            if (config) {
                // Actualizar inputs y variables de la pestaña Básico
                massInput.value = config.params.mass;
                targetMassInput.value = config.params.targetMass;
                angleRange.value = config.params.angle;
                angleInput.value = config.params.angle;
                angleValue.textContent = config.params.angle + '°';
                frictionRange.value = config.params.friction;
                frictionInput.value = config.params.friction;
                frictionValue.textContent = config.params.friction.toFixed(2);
                lengthInput.value = config.params.length;
                gravityInput.value = config.params.gravity;
               
                // Sincronizar variables principales
                mass = config.params.mass;
                targetMass = config.params.targetMass;
                angle = config.params.angle;
                friction = config.params.friction;
                length = config.params.length;
                gravity = config.params.gravity;
               
                // Cargar configuración de poleas
                usePulley = config.params.usePulley;
                if (config.params.usePulley) {
                    counterMassInput.value = config.params.pulleyConfig.counterMass;
                    pulleyConfig.counterMass = config.params.pulleyConfig.counterMass;
                    // Sincronizar inputs de poleas
                    massInputPulley.value = mass;
                    targetMassInputPulley.value = targetMass;
                    angleInputPulley.value = angle;
                    angleRangePulley.value = angle;
                    angleValuePulley.textContent = angle + '°';
                    frictionInputPulley.value = friction;
                    frictionRangePulley.value = friction;
                    frictionValuePulley.textContent = friction.toFixed(2);
                    lengthInputPulley.value = length;
                    gravityInputPulley.value = gravity;
                   
                    // Activar pestaña de poleas
                    document.querySelector('.tab[data-tab="basic"]').classList.remove('active');
                    document.querySelector('.tab[data-tab="pulley"]').classList.add('active');
                    document.getElementById('basic-tab').classList.remove('active');
                    document.getElementById('pulley-tab').classList.add('active');
                } else {
                    // Activar pestaña básica
                    document.querySelector('.tab[data-tab="pulley"]').classList.remove('active');
                    document.querySelector('.tab[data-tab="basic"]').classList.add('active');
                    document.getElementById('pulley-tab').classList.remove('active');
                    document.getElementById('basic-tab').classList.add('active');
                }
               
                // Redibujar simulación
                drawSimulation();
                updateTargetMassIndicator();
                showNotification('Configuración Cargada', `La configuración "${config.name}" se ha cargado correctamente.`, 'success');
            }
        }
       
        // Eliminar configuración
        window.deleteConfig = function(id) {
            if (confirm('¿Está seguro de que desea eliminar esta configuración?')) {
                configHistory = configHistory.filter(c => c.id !== id);
                localStorage.setItem('inclinedPlaneHistory', JSON.stringify(configHistory));
                renderHistory();
                showNotification('Configuración Eliminada', 'La configuración se ha eliminado correctamente.', 'success');
            }
        }
       
        // Configuración del canvas
        function setupCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }
       
        // Sistema de pestañas
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', function() {
                const tabId = this.getAttribute('data-tab');
               
                // Desactivar todas las pestañas
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
               
                // Activar la pestaña seleccionada
                this.classList.add('active');
                document.getElementById(`${tabId}-tab`).classList.add('active');
               
                // Actualizar si estamos usando poleas
                usePulley = (tabId === 'pulley');
               
                // Si cambiamos a la pestaña de poleas, sincronizar valores
                if (usePulley) {
                    massInputPulley.value = mass;
                    targetMassInputPulley.value = targetMass;
                    angleInputPulley.value = angle;
                    angleRangePulley.value = angle;
                    angleValuePulley.textContent = angle + '°';
                    frictionInputPulley.value = friction;
                    frictionRangePulley.value = friction;
                    frictionValuePulley.textContent = friction.toFixed(2);
                    lengthInputPulley.value = length;
                    gravityInputPulley.value = gravity;
                    pulleyConfig.counterMass = parseFloat(counterMassInput.value);
                } else {
                    // Si cambiamos a la pestaña básica, sincronizar valores
                    massInput.value = mass;
                    targetMassInput.value = targetMass;
                    angleInput.value = angle;
                    angleRange.value = angle;
                    angleValue.textContent = angle + '°';
                    frictionInput.value = friction;
                    frictionRange.value = friction;
                    frictionValue.textContent = friction.toFixed(2);
                    lengthInput.value = length;
                    gravityInput.value = gravity;
                }
               
                // Dibujar y actualizar explicación
                drawSimulation();
                updateResultsExplanation();
                if (isRunning) { resetSimulation(); }
            });
        });
       
        // Sincronización de inputs y ranges - Pestaña Básico
        angleRange.addEventListener('input', function() {
            angleValue.textContent = this.value + '°';
            angleInput.value = this.value;
            angle = parseFloat(this.value);
            drawSimulation();
            if (isRunning) { resetSimulation(); }
            updateResultsExplanation();
            angleChanged = true; // Flag para la notificación
        });
        angleRange.addEventListener('change', function() {
            if (angleChanged) {
                // Explicación física del ángulo
                const angleRad = angle * Math.PI / 180;
                const gravitationalForce = mass * gravity * Math.sin(angleRad);
                const frictionForce = friction * mass * gravity * Math.cos(angleRad);
                if (gravitationalForce <= frictionForce) {
                    showNotification('Objeto en Reposo', `El objeto no se moverá con este ángulo (${angle}°), ya que la componente gravitatoria paralela (${gravitationalForce.toFixed(2)} N) es superada por la fuerza de fricción (${frictionForce.toFixed(2)} N).`, 'warning');
                } else {
                    showNotification('Ángulo Modificado', `El ángulo del plano se ha cambiado a ${angle}° Esto afecta la componente gravitatoria paralela al plano.`, 'info');
                }
                angleChanged = false;
            }
        });
       
        frictionRange.addEventListener('input', function() {
            frictionValue.textContent = parseFloat(this.value).toFixed(2);
            frictionInput.value = this.value;
            friction = parseFloat(this.value);
            drawSimulation();
            if (isRunning) { resetSimulation(); }
            updateResultsExplanation();
            frictionChanged = true;
        });
        frictionRange.addEventListener('change', function() {
            if (frictionChanged) {
                // Explicación física de la fricción
                const angleRad = angle * Math.PI / 180;
                const gravitationalForce = mass * gravity * Math.sin(angleRad);
                const normalForce = mass * gravity * Math.cos(angleRad);
                const frictionForce = friction * normalForce;
                const netForceValue = gravitationalForce - frictionForce;
               
                if (netForceValue <= 0) {
                    showNotification('Objeto en Reposo', `El objeto no se mueve porque la fuerza de fricción (${frictionForce.toFixed(2)} N) es mayor o igual que la componente gravitatoria paralela (${gravitationalForce.toFixed(2)} N). Reduzca la fricción o aumente el ángulo.`, 'warning');
                } else {
                    showNotification('Fricción Modificada', `El coeficiente de fricción se ha cambiado a ${parseFloat(this.value).toFixed(2)}. Esto afecta la fuerza de fricción que se opone al movimiento.`, 'info');
                }
                frictionChanged = false;
            }
        });
       
        // Sincronización para la pestaña de poleas - MODIFICADO para notificar solo al soltar
        angleRangePulley.addEventListener('input', function() {
            angleValuePulley.textContent = this.value + '°';
            angleInputPulley.value = this.value;
            angle = parseFloat(this.value);
            drawSimulation();
            if (isRunning) { resetSimulation(); }
            updateResultsExplanation();
            angleChanged = true;
        });
        angleRangePulley.addEventListener('change', function() {
            if (angleChanged) {
                // Explicación física del ángulo con poleas
                const angleRad = angle * Math.PI / 180;
                const gravitationalForce = mass * gravity * Math.sin(angleRad);
                const normalForce = mass * gravity * Math.cos(angleRad);
                const frictionForce = friction * normalForce;
                const counterWeightForce = pulleyConfig.counterMass * gravity;
                const netForce = gravitationalForce - frictionForce - counterWeightForce;
               
                if (netForce <= 0) {
                    showNotification('Objeto en Reposo', `El objeto no se moverá con este ángulo (${angle}°), ya que la fuerza del contrapeso y la fricción superan la componente gravitatoria paralela.`, 'warning');
                } else {
                    showNotification('Ángulo Modificado', `El ángulo del plano se ha cambiado a ${angle}°. Esto afecta la componente gravitatoria paralela al plano.`, 'info');
                }
                angleChanged = false;
            }
        });
       
        frictionRangePulley.addEventListener('input', function() {
            frictionValuePulley.textContent = parseFloat(this.value).toFixed(2);
            frictionInputPulley.value = this.value;
            friction = parseFloat(this.value);
            drawSimulation();
            if (isRunning) { resetSimulation(); }
            updateResultsExplanation();
            frictionChanged = true;
        });
        frictionRangePulley.addEventListener('change', function() {
            if (frictionChanged) {
                // Explicación física de la fricción con poleas
                const angleRad = angle * Math.PI / 180;
                const normalForce = mass * gravity * Math.cos(angleRad);
                const frictionForce = friction * normalForce;
                const gravitationalForce = mass * gravity * Math.sin(angleRad);
                const counterWeightForce = pulleyConfig.counterMass * gravity;
                const netForce = gravitationalForce - frictionForce - counterWeightForce;
               
                if (netForce <= 0) {
                    showNotification('Objeto en Reposo', `El objeto no se mueve porque la fuerza de fricción (${frictionForce.toFixed(2)} N) junto con el contrapeso superan la componente gravitatoria. Reduzca la fricción o ajuste el contrapeso.`, 'warning');
                } else {
                    showNotification('Fricción Modificada', `El coeficiente de fricción se ha cambiado a ${parseFloat(this.value).toFixed(2)}. Esto afecta la fuerza de fricción que se opone al movimiento.`, 'info');
                }
                frictionChanged = false;
            }
        });
       
        // Validación de parámetros
        function validateParameters() {
            let isValid = true;
           
            // Validar masa
            const currentMassInput = usePulley ? massInputPulley : massInput;
            if (parseFloat(currentMassInput.value) <= 0) {
                massValidation.textContent = "La masa debe ser mayor que cero";
                massValidation.style.display = 'block';
                isValid = false;
                showNotification('Error de Validación', 'La masa debe ser mayor que cero.', 'error');
            } else {
                massValidation.style.display = 'none';
            }
           
            // Validar contrapeso si las poleas están activadas
            if (usePulley && parseFloat(counterMassInput.value) <= 0) {
                counterMassValidation.textContent = "La masa del contrapeso debe ser mayor que cero";
                counterMassValidation.style.display = 'block';
                isValid = false;
                showNotification('Error de Validación', 'La masa del contrapeso debe ser mayor que cero.', 'error');
            } else {
                counterMassValidation.style.display = 'none';
            }
           
            return isValid;
        }
       
        // Actualizar valores de los inputs - MODIFICADO para notificar solo al cambiar
        massInput.addEventListener('change', function() {
            let value = parseFloat(this.value);
            if (value < 0.1) value = 0.1;
            this.value = value;
            mass = value;
            updateResultsExplanation();
            drawSimulation();
            if (isRunning) { resetSimulation(); }
            // Sincronizar input de poleas
            massInputPulley.value = value;
            showNotification('Masa Modificada', `La masa del objeto se ha cambiado a ${value} kg. Esto afecta la inercia y la fuerza normal.`, 'info');
        });
       
        targetMassInput.addEventListener('change', function() {
            let value = parseFloat(this.value);
            if (value < 0.1) value = 0.1;
            this.value = value;
            targetMass = value;
            updateResultsExplanation();
            drawSimulation();
            // Sincronizar input de poleas
            targetMassInputPulley.value = value;
            showNotification('Masa Objetivo Modificada', `La masa objetivo se ha cambiado a ${value} kg.`, 'info');
        });
       
        angleInput.addEventListener('change', function() {
            let value = parseFloat(this.value);
            if (value < 1) value = 1;
            if (value > 90) value = 90;
            this.value = value;
            angleRange.value = value;
            angleValue.textContent = value + '°';
            angle = value;
            drawSimulation();
            if (isRunning) { resetSimulation(); }
            updateResultsExplanation();
            showNotification('Ángulo Modificado', `El ángulo del plano se ha cambiado a ${value}°. Esto afecta la componente gravitatoria paralela al plano.`, 'info');
        });
        frictionInput.addEventListener('change', function() {
            let value = parseFloat(this.value);
            if (value < 0) value = 0;
            if (value > 1) value = 1;
            this.value = value;
            frictionRange.value = value;
            frictionValue.textContent = value.toFixed(2);
            friction = value;
            updateResultsExplanation();
            drawSimulation();
            if (isRunning) { resetSimulation(); }
            // Sincronizar input de poleas
            frictionInputPulley.value = value;
            frictionRangePulley.value = value;
            frictionValuePulley.textContent = value.toFixed(2);
            showNotification('Fricción Modificada', `El coeficiente de fricción se ha cambiado a ${value.toFixed(2)}. Esto afecta la fuerza de fricción que se opone al movimiento.`, 'info');
        });
        lengthInput.addEventListener('change', function() {
            let value = parseFloat(this.value);
            if (value < 1) value = 1;
            this.value = value;
            length = value;
            drawSimulation();
            if (isRunning) { resetSimulation(); }
            // Sincronizar input de poleas
            lengthInputPulley.value = value;
            showNotification('Longitud Modificada', `La longitud del plano se ha cambiado a ${value} m. Esto afecta la distancia que recorrerá el objeto.`, 'info');
        });
        gravityInput.addEventListener('change', function() {
            let value = parseFloat(this.value);
            if (value < 1) value = 1;
            this.value = value;
            gravity = value;
            updateResultsExplanation();
            drawSimulation();
            if (isRunning) { resetSimulation(); }
            // Sincronizar input de poleas
            gravityInputPulley.value = value;
            showNotification('Gravedad Modificada', `El valor de la gravedad se ha cambiado a ${value} m/s². Esto afecta todas las fuerzas gravitatorias en el sistema.`, 'info');
        });
       
        // Actualizar valores de los inputs de la pestaña de poleas - MODIFICADO para notificar solo al cambiar
        massInputPulley.addEventListener('change', function() {
            let value = parseFloat(this.value);
            if (value < 0.1) value = 0.1;
            this.value = value;
            mass = value;
            updateResultsExplanation();
            drawSimulation();
            if (isRunning) { resetSimulation(); }
            // Sincronizar input básico
            massInput.value = value;
            showNotification('Masa Modificada', `La masa del objeto se ha cambiado a ${value} kg. Esto afecta la inercia y la fuerza normal.`, 'info');
        });
       
        targetMassInputPulley.addEventListener('change', function() {
            let value = parseFloat(this.value);
            if (value < 0.1) value = 0.1;
            this.value = value;
            targetMass = value;
            updateResultsExplanation();
            drawSimulation();
            // Sincronizar input básico
            targetMassInput.value = value;
            showNotification('Masa Objetivo Modificada', `La masa objetivo se ha cambiado a ${value} kg.`, 'info');
        });
       
        counterMassInput.addEventListener('change', function() {
            let value = parseFloat(this.value);
            if (value < 0.1) value = 0.1;
            this.value = value;
            pulleyConfig.counterMass = value;
            updateResultsExplanation();
            drawSimulation();
            if (isRunning) { resetSimulation(); }
            showNotification('Masa de Contrapeso Modificada', `La masa del contrapeso (M₂) se ha cambiado a ${value} kg. Esto afecta la tensión y la fuerza neta del sistema.`, 'info');
        });
        angleInputPulley.addEventListener('change', function() {
            let value = parseFloat(this.value);
            if (value < 1) value = 1;
            if (value > 90) value = 90;
            this.value = value;
            angleRangePulley.value = value;
            angleValuePulley.textContent = value + '°';
            angle = value;
            drawSimulation();
            if (isRunning) { resetSimulation(); }
            updateResultsExplanation();
            showNotification('Ángulo Modificado', `El ángulo del plano se ha cambiado a ${value}°. Esto afecta la componente gravitatoria paralela al plano.`, 'info');
        });
        frictionInputPulley.addEventListener('change', function() {
            let value = parseFloat(this.value);
            if (value < 0) value = 0;
            if (value > 1) value = 1;
            this.value = value;
            frictionRangePulley.value = value;
            frictionValuePulley.textContent = value.toFixed(2);
            friction = value;
            updateResultsExplanation();
            drawSimulation();
            if (isRunning) { resetSimulation(); }
            // Sincronizar input básico
            frictionInput.value = value;
            frictionRange.value = value;
            frictionValue.textContent = value.toFixed(2);
            showNotification('Fricción Modificada', `El coeficiente de fricción se ha cambiado a ${value.toFixed(2)}. Esto afecta la fuerza de fricción que se opone al movimiento.`, 'info');
        });
        lengthInputPulley.addEventListener('change', function() {
            let value = parseFloat(this.value);
            if (value < 1) value = 1;
            this.value = value;
            length = value;
            drawSimulation();
            if (isRunning) { resetSimulation(); }
            // Sincronizar input básico
            lengthInput.value = value;
            showNotification('Longitud Modificada', `La longitud del plano se ha cambiado a ${value} m. Esto afecta la distancia que recorrerá el objeto.`, 'info');
        });
        gravityInputPulley.addEventListener('change', function() {
            let value = parseFloat(this.value);
            if (value < 1) value = 1;
            this.value = value;
            gravity = value;
            updateResultsExplanation();
            drawSimulation();
            if (isRunning) { resetSimulation(); }
            // Sincronizar input básico
            gravityInput.value = value;
            showNotification('Gravedad Modificada', `El valor de la gravedad se ha cambiado a ${value} m/s². Esto afecta todas las fuerzas gravitatorias en el sistema.`, 'info');
        });
       
        // Función de dibujo del sistema de poleas
        function drawPulleySystem(width, height, baseX, baseY, planeWidth, planeHeight) {
            const pulleyRadius = 15;
            const pulleyX = baseX + planeWidth;
            const pulleyY = baseY - planeHeight;
            const angleRad = angle * Math.PI / 180;
            const inclineLengthCanvas = planeWidth / Math.cos(angleRad);
           
            // 1. Dibujar la polea (círculo)
            ctx.beginPath();
            ctx.arc(pulleyX, pulleyY, pulleyRadius, 0, 2 * Math.PI);
            ctx.fillStyle = '#95a5a6';
            ctx.fill();
            ctx.strokeStyle = '#7f8c8d';
            ctx.lineWidth = 2;
            ctx.stroke();
           
            // Eje central de la polea
            ctx.beginPath();
            ctx.arc(pulleyX, pulleyY, 3, 0, 2 * Math.PI);
            ctx.fillStyle = '#34495e';
            ctx.fill();
           
            // 2. Dibujar el soporte de la polea (rectángulo)
            ctx.fillStyle = '#7f8c8d';
            ctx.fillRect(pulleyX - 5, pulleyY - 35, 10, 20);
            ctx.fillRect(pulleyX - 15, pulleyY - 30, 30, 5); // Base del soporte
           
            // 3. Dibujar la cuerda desde el objeto hasta la polea (RECTA)
           
            // Calculamos la distancia D desde V1 (Top Left) hasta el punto de conexión (esquina superior derecha del bloque)
            // La nueva posición de dibujo invierte el X, por lo que D es la distancia real recorrida desde el punto de inicio de la rampa (que ahora es el final del movimiento físico).
            const distanceAlongIncline = inclineLengthCanvas - (position / length) * inclineLengthCanvas;

            // Coordenadas del punto de conexión en el marco ROTADO (origen en V1/Top Left):
            // X_rot = D (distancia recorrida a lo largo del plano)
            // Y_rot = -massHeight (arriba de la superficie del plano)
            const blockTopRightRotX = distanceAlongIncline;
            const blockTopRightRotY = -massHeight;
           
            // Coordenadas de V1 (Top Left):
            const inclineXStart = baseX;
            const inclineYStart = baseY - planeHeight;

            // Transformación a coordenadas absolutas:
            const blockTopRightAbsX = inclineXStart + blockTopRightRotX * Math.cos(angleRad) - blockTopRightRotY * Math.sin(angleRad);
            const blockTopRightAbsY = inclineYStart + blockTopRightRotX * Math.sin(angleRad) + blockTopRightRotY * Math.cos(angleRad);
           
            // Dibuja la cuerda desde el bloque hasta la polea
            ctx.beginPath();
            ctx.moveTo(blockTopRightAbsX, blockTopRightAbsY);
            // La cuerda va hasta el punto de tangencia inferior de la polea
            ctx.lineTo(pulleyX - pulleyRadius * Math.sin(angleRad), pulleyY + pulleyRadius * Math.cos(angleRad));
           
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 2;
            ctx.stroke();

            // 4. Dibujar la parte vertical de la cuerda y el contrapeso
           
            const maxCounterWeightMovement = 150; // Max movimiento vertical para el contrapeso
            // La masa contrapeso debe descender si la masa M se mueve hacia V1 (Top Left)
            // position=0 (M está en Bottom Right), counterWeightMovement debe ser 0.
            // position=length (M está en Top Left), counterWeightMovement debe ser maxCounterWeightMovement.
            const counterWeightMovement = (position / length) * maxCounterWeightMovement;
            const counterWeightY = pulleyY + pulleyRadius + 30 + counterWeightMovement;
           
            // Parte vertical de la cuerda
            ctx.beginPath();
            ctx.moveTo(pulleyX, pulleyY + pulleyRadius); // Empieza en la parte inferior de la polea
            ctx.lineTo(pulleyX, counterWeightY - 30); // Va hasta la parte superior del contrapeso
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 2;
            ctx.stroke();
           
            // Dibujar el contrapeso
            const counterWeightWidth = 20 + pulleyConfig.counterMass / 2;
            const counterWeightHeight = 15 + pulleyConfig.counterMass / 3;
            ctx.fillStyle = '#3498db';
            ctx.fillRect(pulleyX - counterWeightWidth/2, counterWeightY - counterWeightHeight/2, counterWeightWidth, counterWeightHeight);
            ctx.strokeStyle = '#2980b9';
            ctx.lineWidth = 2;
            ctx.strokeRect(pulleyX - counterWeightWidth/2, counterWeightY - counterWeightHeight/2, counterWeightWidth, counterWeightHeight);
           
            // Etiqueta del contrapeso
            ctx.fillStyle = '#2c3e50';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('M₂', pulleyX, counterWeightY);
           
            ctx.restore();
        }
       
        // Función de dibujo de la simulación
        function drawSimulation() {
            const width = canvas.width;
            const height = canvas.height;
            const angleRad = angle * Math.PI / 180;
           
            // Calcular dimensiones del plano (base horizontal y altura)
            const planeHeight = Math.min(height * 0.5, width * 0.6 * Math.tan(angleRad));
            const planeWidth = planeHeight / Math.tan(angleRad);
            const inclineLengthCanvas = planeWidth / Math.cos(angleRad); // Longitud de la hipotenusa en píxeles
           
            // Ajustar posición inicial del plano (esquina inferior izquierda)
            const baseX = usePulley ? width * 0.4 : width * 0.2;
            const baseY = height - 100;
           
            // Coordenada del vértice superior izquierdo (V1)
            const inclineXStart = baseX;
            const inclineYStart = baseY - planeHeight;
           
            ctx.clearRect(0, 0, width, height);
           
            // Dibujar plano inclinado (V3 -> V2 -> V1)
            ctx.beginPath();
            ctx.moveTo(baseX, baseY); // V3 (Bottom Left, Right Angle)
            ctx.lineTo(baseX + planeWidth, baseY); // V2 (Bottom Right)
            ctx.lineTo(inclineXStart, inclineYStart); // V1 (Top Left)
            ctx.closePath();
            ctx.fillStyle = "#a3c9a8";
            ctx.fill();
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 2;
            ctx.stroke();
           
            // Dibujar poleas si están activadas
            if (usePulley) {
                drawPulleySystem(width, height, baseX, baseY, planeWidth, planeHeight);
            }
           
            // --- DIBUJO DE LA MASA (Sistema de coordenadas ROTADO) ---
           
            ctx.save();
            // 1. Mover el origen al punto de inicio del plano inclinado (Vértice Superior Izquierdo, V1)
            ctx.translate(inclineXStart, inclineYStart);
            // 2. Rotar el canvas para alinear el eje X con la hipotenusa (incline)
            ctx.rotate(angleRad);
           
            // Posición a lo largo del plano inclinado (eje X rotado)
            // Posición de dibujo para que position=0 esté en el BOTTOM RIGHT y position=length esté en el TOP LEFT
            // massDrawX: Distancia desde V1 a la esquina superior izquierda del bloque.
            const distanceMovedFromTop = (position / length) * inclineLengthCanvas;
            const massDrawX = inclineLengthCanvas - distanceMovedFromTop - massWidth;
            const massDrawY = 0; // El plano inclinado es ahora el eje X
           
            // 1. Dibuja el cuerpo (rectángulo)
            // Cambiar color si se alcanzó la masa objetivo
            const currentMassColor = mass >= targetMass ? targetMassColor : massColor;
            ctx.fillStyle = currentMassColor;
            ctx.strokeStyle = massBorderColor;
            ctx.lineWidth = 1.5;
           
            // Dibuja el rectángulo desde la esquina superior izquierda (ajustado para sentarse en el eje X)
            ctx.fillRect(massDrawX, massDrawY - massHeight, massWidth, massHeight);
            ctx.strokeRect(massDrawX, massDrawY - massHeight, massWidth, massHeight);
           
            // 2. Dibuja el centro de masa (círculo rojo)
            const massCenterX = massDrawX + massWidth / 2;
            const massCenterY = massDrawY - massHeight / 2; // Centro vertical
           
            ctx.beginPath();
            ctx.arc(massCenterX, massCenterY, 3.5, 0, 2 * Math.PI); // Radio de 3.5px para el punto
            ctx.fillStyle = massCenterColor; // Rojo
            ctx.fill();
            ctx.strokeStyle = '#000'; // Pequeño borde negro para contraste
            ctx.lineWidth = 0.5;
            ctx.stroke();
           
            ctx.restore();
            // --- FIN DIBUJO DE LA MASA ---
           
            // --- DIBUJO DEL ÁNGULO θ (en esquina inferior derecha, V2) ---
           
            // Coordenadas de V2 (Bottom Right)
            const angleArcRadius = 30;
            const angleArcX = baseX + planeWidth;
            const angleArcY = baseY;
           
            ctx.beginPath();
            // Arco desde el horizontal (0) hasta el plano inclinado (-angleRad), en sentido horario (true)
            ctx.arc(angleArcX, angleArcY, angleArcRadius, 0, -angleRad, true);
            ctx.strokeStyle = '#e74c3c';
            ctx.lineWidth = 2;
            ctx.stroke();
           
            ctx.fillStyle = '#e74c3c';
            ctx.font = 'bold 18px Arial';
            const thetaTextRadius = angleArcRadius * 0.6;
            // Posición del texto en el centro del arco
            const centerAngle = -angleRad / 2;
            const thetaX = angleArcX + thetaTextRadius * Math.cos(centerAngle);
            const thetaY = angleArcY + thetaTextRadius * Math.sin(centerAngle);
            ctx.fillText('θ', thetaX, thetaY);
           
            // --- FIN DIBUJO DEL ÁNGULO θ ---
           
            // Dibujar el cuadrado de 90° en la esquina inferior izquierda (V3)
            const squareSize = 15;
            const squareX = baseX + squareSize/2;
            const squareY = baseY - squareSize/2;
            ctx.beginPath();
            ctx.moveTo(squareX - squareSize/2, squareY - squareSize/2);
            ctx.lineTo(squareX + squareSize/2, squareY - squareSize/2);
            ctx.lineTo(squareX + squareSize/2, squareY + squareSize/2);
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            ctx.stroke();
           
            // Dibujar etiqueta de masa
            ctx.fillStyle = '#2c3e50';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            const labelX = baseX + planeWidth / 2;
            const labelY = baseY - planeHeight / 2;
            ctx.fillText(`M = ${mass.toFixed(1)} kg`, labelX, labelY - 20);
           
            // Dibujar etiqueta de masa objetivo si es diferente
            if (targetMass !== mass) {
                ctx.fillStyle = targetMassColor;
                ctx.fillText(`Objetivo: ${targetMass.toFixed(1)} kg`, labelX, labelY + 20);
            }
        }
       
        // Función principal de física - SE MANTIENE EL CÁLCULO
        function calculatePhysics() {
            if (!isRunning || isPaused) return;
           
            const angleRad = angle * Math.PI / 180;
            const normalForce = mass * gravity * Math.cos(angleRad);
            const gravitationalParallelForce = mass * gravity * Math.sin(angleRad);
            const frictionMaxMagnitude = friction * normalForce;
           
            let netForceValue;
            let counterMass = usePulley ? pulleyConfig.counterMass : 0;
            const totalMass = mass + counterMass;

            // Fuerza impulsora neta (sin fricción) - Positivo = Down the plane
            let drivingForce = gravitationalParallelForce;
            if (usePulley) {
                drivingForce -= counterMass * gravity;
            }
           
            if (velocity === 0) {
                // Fricción Estática
                if (Math.abs(drivingForce) > frictionMaxMagnitude) {
                    // El movimiento comienza (Fuerza neta > Fricción estática máxima)
                    netForceValue = drivingForce - Math.sign(drivingForce) * frictionMaxMagnitude;
                    acceleration = netForceValue / totalMass;
                } else {
                    // Reposo (Fricción estática balancea la drivingForce)
                    acceleration = 0;
                    netForceValue = 0;
                }
            } else {
                // Fricción Cinética (opuesta al movimiento)
                const directionOfMotion = Math.sign(velocity);
               
                // La fricción se resta si el movimiento es a favor de drivingForce, se suma si es en contra.
                // Simplificado: F_net = DrivingForce - (dirección * fricciónMax)
                netForceValue = drivingForce - directionOfMotion * frictionMaxMagnitude;
                acceleration = netForceValue / totalMass;
            }
           
            // Integración de Euler simple
            velocity += acceleration * deltaTime;
           
            // No permitir que el objeto vaya hacia arriba de la parte superior (position < 0)
            if (position <= 0 && velocity < 0) {
                velocity = 0;
                position = 0;
                // Si el objeto intenta subir al inicio (solo con polea), la aceleración debe ser cero si no hay fuerza impulsora.
                if (usePulley && drivingForce < 0 && Math.abs(drivingForce) <= frictionMaxMagnitude) {
                    acceleration = 0;
                    netForceValue = 0;
                }
            }
           
            // No permitir que el objeto sobrepase la longitud del plano
            if (position >= length && velocity > 0) {
                velocity = 0;
                position = length;
                isRunning = false;
                showNotification('Simulación Completada', 'El objeto ha llegado al final del plano inclinado.', 'success');
            } else {
                position += velocity * deltaTime;
            }
           
            currentTime += deltaTime;
           
            // Calcular energía
            const heightFromBase = position * Math.sin(angleRad);
            const potentialEnergy = mass * gravity * heightFromBase; // Potencial relativo a la base
            const kineticEnergy = 0.5 * mass * velocity * velocity;
            energy = potentialEnergy + kineticEnergy;
            netForce = netForceValue;
           
            // Actualizar valores en pantalla
            timeValue.textContent = currentTime.toFixed(2) + " s";
            positionValue.textContent = position.toFixed(2) + " M";
            velocityValue.textContent = velocity.toFixed(2) + " M/s";
            accelerationValue.textContent = acceleration.toFixed(2) + " M/s²";
            forceValue.textContent = netForce.toFixed(2) + " N";
            energyValue.textContent = energy.toFixed(2) + " J";
           
            // Actualizar explicación de resultados
            updateResultsExplanation();
           
            // Guardar datos para exportación
            if (isRunning && !isPaused) {
                simulationData.push({
                    time: currentTime,
                    position: position,
                    velocity: velocity,
                    acceleration: acceleration,
                    force: netForce,
                    energy: energy
                });
            }
        }
       
        // Bucle de animación
        function animate() {
            calculatePhysics();
            drawSimulation();
            if (isRunning && !isPaused) {
                animationId = requestAnimationFrame(animate);
            }
        }
       
        // Función para iniciar simulación
        startBtn.addEventListener('click', function() {
            if (!validateParameters()) return;
           
            if (!isRunning) {
                // Reiniciar al iniciar por primera vez o después de reset
                resetSimulation();
                isRunning = true;
                isPaused = false;
                animate();
                startBtn.innerHTML = `<svg class="icon" viewBox="0 0 24 24"><path d="M19 12l-7 7-7-7z"/></svg> Detener Simulación`;
                startBtn.classList.add('reset-btn');
                startBtn.classList.remove('start-btn');
                pauseBtn.style.display = 'flex';
            } else {
                // Detener simulación
                isRunning = false;
                startBtn.innerHTML = `<svg class="icon" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg> Iniciar Simulación`;
                startBtn.classList.remove('reset-btn');
                startBtn.classList.add('start-btn');
            }
        });
       
        // Función para reiniciar simulación
        function resetSimulation() {
            isRunning = false;
            isPaused = false;
            currentTime = 0;
            position = 0;
            velocity = 0;
            acceleration = 0;
            energy = 0;
            netForce = 0;
            simulationData = [];
            targetMassAchieved = false;
           
            // Actualizar inputs (por si se cambiaron los valores del number-input directamente)
            if (usePulley) {
                mass = parseFloat(massInputPulley.value);
                targetMass = parseFloat(targetMassInputPulley.value);
                angle = parseFloat(angleInputPulley.value);
                friction = parseFloat(frictionInputPulley.value);
                length = parseFloat(lengthInputPulley.value);
                gravity = parseFloat(gravityInputPulley.value);
                pulleyConfig.counterMass = parseFloat(counterMassInput.value);
            } else {
                mass = parseFloat(massInput.value);
                targetMass = parseFloat(targetMassInput.value);
                angle = parseFloat(angleInput.value);
                friction = parseFloat(frictionInput.value);
                length = parseFloat(lengthInput.value);
                gravity = parseFloat(gravityInput.value);
            }
           
            drawSimulation();
            updateResultsExplanation();
           
            timeValue.textContent = "0.00 s";
            positionValue.textContent = "0.00 M";
            velocityValue.textContent = "0.00 M/s";
            accelerationValue.textContent = "0.00 M/s²";
            forceValue.textContent = "0.00 N";
            energyValue.textContent = "0.00 J";
           
            startBtn.innerHTML = `<svg class="icon" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg> Iniciar Simulación`;
            startBtn.classList.remove('reset-btn');
            startBtn.classList.add('start-btn');
            pauseBtn.innerHTML = `<svg class="icon" viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg> Pausar`;
            pauseBtn.style.backgroundColor = 'var(--warning-color)';
        }
        resetBtn.addEventListener('click', resetSimulation);
       
        // Función para pausar/reanudar
        pauseBtn.addEventListener('click', function() {
            if (isRunning) {
                isPaused = !isPaused;
                if (isPaused) {
                    pauseBtn.innerHTML = `<svg class="icon" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg> Reanudar`;
                    pauseBtn.style.backgroundColor = 'var(--success-color)';
                    showNotification('Simulación Pausada', 'La simulación se ha pausado. Presiona Reanudar para continuar.', 'info');
                } else {
                    pauseBtn.innerHTML = `<svg class="icon" viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg> Pausar`;
                    pauseBtn.style.backgroundColor = 'var(--warning-color)';
                    animate();
                    showNotification('Simulación Reanudada', 'Continuando la simulación.', 'info');
                }
            }
        });
       
        // Función para exportar datos a CSV
        function exportData() {
            if (simulationData.length === 0) {
                showNotification('Error de Exportación', 'No hay datos de simulación para exportar. Inicie la simulación primero.', 'error');
                return;
            }
           
            // Encabezado
            let csvContent = "PARAMETROS DE LA SIMULACIÓN\n";
            csvContent += `Masa (M): ${mass} kg\n`;
            csvContent += `Masa objetivo: ${targetMass} kg\n`;
            csvContent += `Ángulo (θ): ${angle}°\n`;
            csvContent += `Coeficiente de Fricción (μ): ${friction}\n`;
            csvContent += `Longitud del plano: ${length} m\n`;
            csvContent += `Gravedad: ${gravity} m/s²\n`;
            csvContent += `Sistema de poleas: ${usePulley ? "Activado" : "Desactivado"}\n`;
            if (usePulley) {
                csvContent += `Masa del contrapeso: ${pulleyConfig.counterMass} kg\n`;
            }
            csvContent += `Masa objetivo alcanzada: ${targetMassAchieved ? "Sí" : "No"}\n`;
            csvContent += `Fecha de simulación: ${new Date().toLocaleString()}\n\n`;
           
            // Resumen de resultados
            csvContent += "RESUMEN DE RESULTADOS\n";
            const finalTime = simulationData[simulationData.length - 1].time;
            const finalPosition = simulationData[simulationData.length - 1].position;
            const maxVelocity = Math.max(...simulationData.map(d => Math.abs(d.velocity)));
            const maxAcceleration = Math.max(...simulationData.map(d => Math.abs(d.acceleration)));
            csvContent += `Tiempo total de simulación: ${finalTime.toFixed(2)} s\n`;
            csvContent += `Distancia recorrida: ${finalPosition.toFixed(2)} m\n`;
            csvContent += `Velocidad máxima: ${maxVelocity.toFixed(2)} m/s\n`;
            csvContent += `Aceleración máxima: ${maxAcceleration.toFixed(2)} m/s²\n`;
            csvContent += `Estado final: ${finalPosition >= length ? "Completado" : "En progreso"}\n\n`;
           
            // Datos detallados
            csvContent += "DATOS DETALLADOS DE LA SIMULACIÓN\n";
            csvContent += "Tiempo (s),Posición (m),Velocidad (m/s),Aceleración (m/s²),Fuerza Neta (N),Energía (J)\n";
            simulationData.forEach(data => {
                csvContent += `${data.time.toFixed(3)},${data.position.toFixed(3)},${data.velocity.toFixed(3)},${data.acceleration.toFixed(3)},${data.force.toFixed(3)},${data.energy.toFixed(3)}\n`;
            });
           
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.setAttribute('href', url);
            link.setAttribute('download', `simulacion_plano_inclinado_${new Date().toISOString()}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
           
            showNotification('Exportación Exitosa', 'Los datos se han exportado correctamente en formato CSV.', 'success');
        }
       
        // Función para exportar a Excel (XLSX)
        function exportToExcel() {
            if (simulationData.length === 0) {
                showNotification('Error de Exportación', 'No hay datos de simulación para exportar. Inicie la simulación primero.', 'error');
                return;
            }
           
            const wb = XLSX.utils.book_new();
            const wsData = [
                ["Tiempo (s)", "Posición (m)", "Velocidad (m/s)", "Aceleración (m/s²)", "Fuerza Neta (N)", "Energía (J)"],
                ...simulationData.map(d => [d.time.toFixed(3), d.position.toFixed(3), d.velocity.toFixed(3), d.acceleration.toFixed(3), d.force.toFixed(3), d.energy.toFixed(3)])
            ];
            const ws = XLSX.utils.aoa_to_sheet(wsData);
            XLSX.utils.book_append_sheet(wb, ws, "Datos");
           
            // Hoja de Resumen
            const finalTime = simulationData[simulationData.length - 1].time;
            const finalPosition = simulationData[simulationData.length - 1].position;
            const maxVelocity = Math.max(...simulationData.map(d => Math.abs(d.velocity)));
            const maxAcceleration = Math.max(...simulationData.map(d => Math.abs(d.acceleration)));
           
            const angleRad = angle * Math.PI / 180;
           
            const summaryData = [
                ["RESUMEN DE RESULTADOS"],
                ["Tiempo total de simulación:", finalTime.toFixed(2), "s"],
                ["Distancia recorrida:", finalPosition.toFixed(2), "m"],
                ["Velocidad máxima:", maxVelocity.toFixed(2), "m/s"],
                ["Aceleración máxima:", maxAcceleration.toFixed(2), "m/s²"],
                ["Estado final:", finalPosition >= length ? "Completado" : "En progreso", ""],
                ["Masa objetivo alcanzada:", targetMassAchieved ? "Sí" : "No", ""],
                [""],
                ["ANÁLISIS FÍSICO"],
                ["Fuerza gravitatoria paralela:", (mass * gravity * Math.sin(angleRad)).toFixed(2), "N"],
                ["Fuerza normal:", (mass * gravity * Math.cos(angleRad)).toFixed(2), "N"],
                ["Fuerza de fricción máxima:", (friction * mass * gravity * Math.cos(angleRad)).toFixed(2), "N"],
                ...(usePulley ? [["Fuerza del contrapeso:", (pulleyConfig.counterMass * gravity).toFixed(2), "N"]] : []),
                ["Fuerza neta inicial:", simulationData[0]?.force.toFixed(2) || "0.00", "N"]
            ];
            const summaryWs = XLSX.utils.aoa_to_sheet(summaryData);
            XLSX.utils.book_append_sheet(wb, summaryWs, "Resumen");
           
            XLSX.writeFile(wb, `simulacion_plano_inclinado_${new Date().toISOString()}.xlsx`);
            showNotification('Exportación Exitosa', 'Los datos se han exportado correctamente en formato XLSX (Excel).', 'success');
        }
       
        // Manejador del botón de exportar para elegir formato
        exportBtn.addEventListener('click', function() {
            if (typeof XLSX !== 'undefined') {
                // Crear un menú desplegable para elegir el formato
                const exportMenu = document.createElement('div');
                exportMenu.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: white;
                    padding: 20px;
                    border-radius: 10px;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                    z-index: 1000;
                    min-width: 250px;
                    text-align: center;
                `;
                exportMenu.innerHTML = `
                    <h3 style="margin-bottom: 15px; color: var(--primary-color);">Seleccione formato de exportación</h3>
                    <button id="excel-export" style="background: var(--success-color); margin-bottom: 10px;">
                        <svg class="icon" viewBox="0 0 24 24"><path d="M21 8h-6V3H9v5H3l9 9 9-9zM3 18v2h18v-2H3z"/></svg>
                        Exportar a XLSX (Excel)
                    </button>
                    <button id="csv-export" style="background: var(--accent-color); margin-bottom: 10px;">
                        <svg class="icon" viewBox="0 0 24 24"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>
                        Exportar a CSV
                    </button>
                    <button id="cancel-export" class="reset-btn" style="background: var(--danger-color); margin-top: 5px;">
                        Cancelar
                    </button>
                `;
               
                document.body.appendChild(exportMenu);
               
                // Event listeners para los botones
                document.getElementById('excel-export').addEventListener('click', function() {
                    document.body.removeChild(exportMenu);
                    exportToExcel();
                });
               
                document.getElementById('csv-export').addEventListener('click', function() {
                    document.body.removeChild(exportMenu);
                    exportData();
                });
               
                document.getElementById('cancel-export').addEventListener('click', function() {
                    document.body.removeChild(exportMenu);
                });
            } else {
                // Si SheetJS no está disponible, usar CSV por defecto
                exportData();
            }
        });
       
        // Inicialización
        window.addEventListener('load', function() {
            setupCanvas();
            drawSimulation();
            updateResultsExplanation();
            showNotification('Bienvenido', 'El laboratorio virtual de plano inclinado está listo. Configure los parámetros y presione "Iniciar Simulación".', 'info');
        });
       
        window.addEventListener('resize', function() {
            setupCanvas();
            drawSimulation();
        });
    </script>
</body>
</html>
