<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Laboratorio Virtual - Plano Inclinado</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        /* Todo el CSS permanece igual */
        :root {
            --primary-color: #1a365d;
            --secondary-color: #2d3748;
            --accent-color: #3182ce;
            --light-color: #f7fafc;
            --dark-color: #1a202c;
            --success-color: #38a169;
            --warning-color: #d69e2e;
            --danger-color: #e53e3e;
            --text-color: #2d3748;
            --border-radius: 10px;
            --box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            --transition: all 0.3s ease;
        }
       
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
       
        /* ... resto del CSS igual ... */
    </style>
</head>
<body>
    <!-- Todo el HTML permanece igual -->
    <div class="container">
        <header>
            <div class="header-content">
                <div class="header-title">
                    <h1>Laboratorio Virtual: Plano Inclinado</h1>
                    <p class="subtitle">Simulador interactivo para el estudio de la física del movimiento</p>
                </div>
            </div>
        </header>
       
        <div class="content">
            <!-- Panel de configuración -->
            <div class="panel">
                <h2>Configuración del Experimento</h2>
               
                <div class="tabs">
                    <div class="tab active" data-tab="basic">Básico</div>
                    <div class="tab" data-tab="pulley">Poleas</div>
                </div>
               
                <!-- Contenido de pestañas -->
                <div class="tab-content active" id="basic-tab">
                    <!-- ... inputs básicos iguales ... -->
                </div>
               
                <div class="tab-content" id="pulley-tab">
                    <!-- ... inputs de poleas iguales ... -->
                </div>
               
                <button id="start-btn">
                    <svg class="icon" viewBox="0 0 24 24">
                        <path d="M8 5v14l11-7z"/>
                    </svg>
                    Iniciar Simulación
                </button>
                <button id="save-config-btn" style="background: var(--success-color);">
                    <svg class="icon" viewBox="0 0 24 24">
                        <path d="M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7l-4-4zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm3-10H5V5h10v4z"/>
                    </svg>
                    Guardar Configuración
                </button>
                <button id="reset-btn" class="reset-btn">
                    <svg class="icon" viewBox="0 0 24 24">
                        <path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/>
                    </svg>
                    Reiniciar
                </button>
            </div>
           
            <!-- Área de simulación -->
            <div class="simulation-area">
                <div class="canvas-container">
                    <h2>Visualización del Experimento</h2>
                    <canvas id="simulation-canvas"></canvas>
                </div>
               
                <div class="data-display">
                    <!-- ... datos iguales ... -->
                </div>
               
                <div class="controls">
                    <button id="pause-btn" class="pause-btn">
                        <svg class="icon" viewBox="0 0 24 24">
                            <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>
                        </svg>
                        Pausar
                    </button>
                    <button id="export-btn" class="export-btn">
                        <svg class="icon" viewBox="0 0 24 24">
                            <path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/>
                        </svg>
                        Exportar Datos
                    </button>
                </div>
               
                <!-- Historial -->
                <div class="history-container">
                    <h2>Historial de Configuraciones</h2>
                    <div class="history-list" id="history-list">
                        <div class="empty-history" id="empty-history">No hay configuraciones guardadas. Guarda una configuración para verla aquí.</div>
                    </div>
                </div>
            </div>
        </div>
       
        <!-- Sección de resultados -->
        <div class="results-container">
            <h2>Resultados y Explicación del Sistema</h2>
            <div class="results-explanation">
                <h4>Análisis del Movimiento</h4>
                <p id="movement-analysis">El sistema está en reposo. Inicie la simulación para ver el análisis del movimiento.</p>
                <h4>Comportamiento del Sistema</h4>
                <p id="system-behavior">El objeto permanecerá en reposo o se moverá dependiendo de la relación entre la fuerza gravitatoria paralela al plano y la fuerza de fricción.</p>
                <h4>Explicación del Desplazamiento</h4>
                <p id="displacement-explanation">El desplazamiento del objeto está determinado por la fuerza neta que actúa sobre él. Si la componente gravitatoria paralela al plano supera la fuerza de fricción, el objeto acelerará hacia abajo del plano.</p>
            </div>
        </div>
       
        <!-- Panel de información -->
        <div class="info-panel">
            <h2>Fundamentos Teóricos</h2>
           
            <div class="tabs">
                <div class="tab active" data-tab="theory">Teoría</div>
                <div class="tab" data-tab="formulas">Fórmulas</div>
                <div class="tab" data-tab="instructions">Instrucciones</div>
            </div>
           
            <!-- ... contenido de pestañas igual ... -->
        </div>
       
        <footer>
            <p>Laboratorio Virtual de Física - Simulador de Plano Inclinado con Poleas y sin poleas</p>
            <p>© 2023 - Departamento de Física - Universidad Virtual</p>
        </footer>
    </div>

    <!-- Contenedor para notificaciones -->
    <div class="notification-container" id="notification-container"></div>

    <script>
        // Elementos del DOM
        const canvas = document.getElementById('simulation-canvas');
        const ctx = canvas.getContext('2d');
       
        // Inputs numéricos
        const massInput = document.getElementById('mass-input');
        const angleInput = document.getElementById('angle-input');
        const angleRange = document.getElementById('angle-range');
        const angleValue = document.getElementById('angle-value');
        const frictionInput = document.getElementById('friction-input');
        const frictionRange = document.getElementById('friction-range');
        const frictionValue = document.getElementById('friction-value');
        const lengthInput = document.getElementById('length-input');
        const gravityInput = document.getElementById('gravity-input');
       
        // Inputs de la pestaña Poleas
        const massInputPulley = document.getElementById('mass-input-pulley');
        const angleInputPulley = document.getElementById('angle-input-pulley');
        const angleRangePulley = document.getElementById('angle-range-pulley');
        const angleValuePulley = document.getElementById('angle-value-pulley');
        const frictionInputPulley = document.getElementById('friction-input-pulley');
        const frictionRangePulley = document.getElementById('friction-range-pulley');
        const frictionValuePulley = document.getElementById('friction-value-pulley');
        const lengthInputPulley = document.getElementById('length-input-pulley');
        const gravityInputPulley = document.getElementById('gravity-input-pulley');
       
        // Configuración de poleas
        const counterMassInput = document.getElementById('counter-mass-input');
       
        // Botones
        const startBtn = document.getElementById('start-btn');
        const pauseBtn = document.getElementById('pause-btn');
        const resetBtn = document.getElementById('reset-btn');
        const exportBtn = document.getElementById('export-btn');
        const saveConfigBtn = document.getElementById('save-config-btn');
       
        // Historial
        const historyList = document.getElementById('history-list');
        const emptyHistory = document.getElementById('empty-history');
       
        // Valores de datos
        const timeValue = document.getElementById('time-value');
        const positionValue = document.getElementById('position-value');
        const velocityValue = document.getElementById('velocity-value');
        const accelerationValue = document.getElementById('acceleration-value');
        const forceValue = document.getElementById('force-value');
        const energyValue = document.getElementById('energy-value');
       
        // Mensajes de validación
        const massValidation = document.getElementById('mass-validation');
        const massValidationPulley = document.getElementById('mass-validation-pulley');
        const counterMassValidation = document.getElementById('counter-mass-validation');
       
        // Elementos de resultados
        const movementAnalysis = document.getElementById('movement-analysis');
        const systemBehavior = document.getElementById('system-behavior');
        const displacementExplanation = document.getElementById('displacement-explanation');
       
        // Variables de simulación
        let animationId;
        let isRunning = false;
        let isPaused = false;
        let currentTime = 0;
        let position = 0;
        let velocity = 0;
        let acceleration = 0;
        let netForce = 0;
        let energy = 0;
        let simulationData = [];
       
        // Parámetros iniciales
        let mass = parseFloat(massInput.value);
        let angle = parseFloat(angleInput.value);
        let friction = parseFloat(frictionInput.value);
        let length = parseFloat(lengthInput.value);
        let gravity = parseFloat(gravityInput.value);
        let usePulley = false;
        let pulleyConfig = {
            counterMass: parseFloat(counterMassInput.value)
        };

        // Variables para controlar notificaciones
        let angleChanged = false;
        let frictionChanged = false;
       
        // Historial de configuraciones
        let configHistory = JSON.parse(localStorage.getItem('inclinedPlaneHistory')) || [];
       
        // Inicializar el historial
        renderHistory();
       
        // Función para mostrar notificaciones
        function showNotification(title, message, type = 'info') {
            const notificationContainer = document.getElementById('notification-container');
            const notification = document.createElement('div');
            notification.className = 'notification';
           
            let icon = 'ℹ️';
            if (type === 'warning') icon = '⚠️';
            if (type === 'error') icon = '❌';
            if (type === 'success') icon = '✅';
           
            notification.innerHTML = `
                <div class="notification-icon">${icon}</div>
                <div class="notification-content">
                    <div class="notification-title">${title}</div>
                    <div class="notification-message">${message}</div>
                </div>
                <button class="notification-close">&times;</button>
            `;
           
            notificationContainer.appendChild(notification);
           
            // Cerrar notificación al hacer clic en la X
            notification.querySelector('.notification-close').addEventListener('click', function() {
                notification.remove();
            });
           
            // Auto-eliminar después de 5 segundos
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.remove();
                }
            }, 5000);
        }
       
        // Función para actualizar la sección de resultados
        function updateResultsExplanation() {
            const angleRad = angle * Math.PI / 180;
            const gravitationalForce = mass * gravity * Math.sin(angleRad);
            const normalForce = mass * gravity * Math.cos(angleRad);
            const frictionForce = friction * normalForce;
            let netForceValue = gravitationalForce - frictionForce;
           
            // Análisis del movimiento
            if (netForceValue > 0) {
                movementAnalysis.textContent = `El objeto se está moviendo hacia abajo del plano. La fuerza gravitatoria paralela (${gravitationalForce.toFixed(2)} N) es mayor que la fuerza de fricción (${frictionForce.toFixed(2)} N).`;
            } else if (netForceValue < 0) {
                movementAnalysis.textContent = `El objeto se está moviendo hacia arriba del plano. La fuerza de fricción (${frictionForce.toFixed(2)} N) es mayor que la fuerza gravitatoria paralela (${gravitationalForce.toFixed(2)} N).`;
            } else {
                movementAnalysis.textContent = `El objeto está en equilibrio. La fuerza gravitatoria paralela (${gravitationalForce.toFixed(2)} N) es igual a la fuerza de fricción (${frictionForce.toFixed(2)} N).`;
            }
           
            // Comportamiento del sistema
            if (usePulley) {
                const counterWeightForce = pulleyConfig.counterMass * gravity;
                systemBehavior.textContent = `El sistema de poleas está activado. El contrapeso de ${pulleyConfig.counterMass} kg ejerce una fuerza de ${counterWeightForce.toFixed(2)} N.`;
            } else {
                systemBehavior.textContent = `El sistema de poleas está desactivado. El movimiento está determinado únicamente por la gravedad y la fricción.`;
            }
           
            // Explicación del desplazamiento
            if (acceleration > 0) {
                displacementExplanation.textContent = `El objeto está acelerando hacia abajo del plano con una aceleración de ${acceleration.toFixed(2)} m/s². La velocidad aumenta con el tiempo.`;
            } else if (acceleration < 0) {
                displacementExplanation.textContent = `El objeto está desacelerando (aceleración negativa de ${acceleration.toFixed(2)} m/s²). La velocidad disminuye con el tiempo.`;
            } else {
                displacementExplanation.textContent = `El objeto se mueve con velocidad constante o está en reposo. No hay aceleración neta.`;
            }
        }

        // Guardar configuración actual
        saveConfigBtn.addEventListener('click', function() {
            const configName = prompt("Ingrese un nombre para esta configuración:",
                `Configuración ${new Date().toLocaleTimeString()}`);
           
            if (configName) {
                const config = {
                    id: Date.now(),
                    name: configName,
                    timestamp: new Date().toISOString(),
                    params: {
                        mass: mass,
                        angle: angle,
                        friction: friction,
                        length: length,
                        gravity: gravity,
                        usePulley: usePulley,
                        pulleyConfig: {...pulleyConfig}
                    }
                };
               
                // Agregar al inicio del array
                configHistory.unshift(config);
               
                // Limitar a 10 configuraciones
                if (configHistory.length > 10) {
                    configHistory = configHistory.slice(0, 10);
                }
               
                // Guardar en localStorage
                localStorage.setItem('inclinedPlaneHistory', JSON.stringify(configHistory));
               
                // Actualizar vista
                renderHistory();
               
                showNotification('Configuración Guardada', `La configuración "${configName}" se ha guardado correctamente.`, 'success');
            }
        });
       
        // Renderizar historial
        function renderHistory() {
            if (configHistory.length === 0) {
                emptyHistory.style.display = 'block';
                historyList.innerHTML = '';
                historyList.appendChild(emptyHistory);
                return;
            }
           
            emptyHistory.style.display = 'none';
            historyList.innerHTML = '';
           
            configHistory.forEach(config => {
                const item = document.createElement('div');
                item.className = 'history-item';
               
                const date = new Date(config.timestamp);
                const dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
               
                let paramsText = `Masa: ${config.params.mass}kg, Ángulo: ${config.params.angle}°, Fricción: ${config.params.friction}`;
                if (config.params.usePulley) {
                    paramsText += `, Contrapeso: ${config.params.pulleyConfig.counterMass}kg`;
                }
               
                item.innerHTML = `
                    <div class="history-details">
                        <div class="history-title">${config.name}</div>
                        <div class="history-params">${paramsText}</div>
                        <div class="history-date">${dateStr}</div>
                    </div>
                    <div class="history-actions">
                        <button class="history-btn-small load" data-id="${config.id}">Cargar</button>
                        <button class="history-btn-small delete" data-id="${config.id}">Eliminar</button>
                    </div>
                `;
               
                historyList.appendChild(item);
            });
           
            // Agregar event listeners a los botones
            document.querySelectorAll('.history-btn-small.load').forEach(btn => {
                btn.addEventListener('click', function() {
                    const id = parseInt(this.getAttribute('data-id'));
                    loadConfig(id);
                });
            });
           
            document.querySelectorAll('.history-btn-small.delete').forEach(btn => {
                btn.addEventListener('click', function() {
                    const id = parseInt(this.getAttribute('data-id'));
                    deleteConfig(id);
                });
            });
        }
       
        // Cargar configuración
        function loadConfig(id) {
            const config = configHistory.find(c => c.id === id);
            if (config) {
                // Cargar parámetros básicos
                massInput.value = config.params.mass;
                mass = config.params.mass;
               
                angleInput.value = config.params.angle;
                angleRange.value = config.params.angle;
                angleValue.textContent = config.params.angle + '°';
                angle = config.params.angle;
               
                frictionInput.value = config.params.friction;
                frictionRange.value = config.params.friction;
                frictionValue.textContent = config.params.friction.toFixed(2);
                friction = config.params.friction;
               
                lengthInput.value = config.params.length;
                length = config.params.length;
               
                gravityInput.value = config.params.gravity;
                gravity = config.params.gravity;
               
                // Cargar configuración de poleas
                usePulley = config.params.usePulley;
               
                if (config.params.usePulley) {
                    counterMassInput.value = config.params.pulleyConfig.counterMass;
                    pulleyConfig.counterMass = config.params.pulleyConfig.counterMass;
                }
               
                // Redibujar simulación
                drawSimulation();
               
                showNotification('Configuración Cargada', `La configuración "${config.name}" se ha cargado correctamente.`, 'success');
            }
        }
       
        // Eliminar configuración
        function deleteConfig(id) {
            if (confirm('¿Está seguro de que desea eliminar esta configuración?')) {
                configHistory = configHistory.filter(c => c.id !== id);
                localStorage.setItem('inclinedPlaneHistory', JSON.stringify(configHistory));
                renderHistory();
                showNotification('Configuración Eliminada', 'La configuración se ha eliminado correctamente.', 'success');
            }
        }

        // Configuración del canvas
        function setupCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }
       
        // Sistema de pestañas
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', function() {
                const tabId = this.getAttribute('data-tab');
               
                // Desactivar todas las pestañas
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
               
                // Activar la pestaña seleccionada
                this.classList.add('active');
                document.getElementById(`${tabId}-tab`).classList.add('active');
               
                // Actualizar si estamos usando poleas
                usePulley = (tabId === 'pulley');
               
                // Si cambiamos a la pestaña de poleas, sincronizar valores
                if (usePulley) {
                    massInputPulley.value = mass;
                    angleInputPulley.value = angle;
                    angleRangePulley.value = angle;
                    angleValuePulley.textContent = angle + '°';
                    frictionInputPulley.value = friction;
                    frictionRangePulley.value = friction;
                    frictionValuePulley.textContent = friction.toFixed(2);
                    lengthInputPulley.value = length;
                    gravityInputPulley.value = gravity;
                }
               
                // Redibujar la simulación inmediatamente
                drawSimulation();
            });
        });
       
        // Sincronización de inputs de rango y número - MODIFICADO para notificar solo al soltar
        angleRange.addEventListener('input', function() {
            angleValue.textContent = this.value + '°';
            angleInput.value = this.value;
            angle = parseFloat(this.value);
            drawSimulation();
            if (isRunning) {
                resetSimulation();
            }
            updateResultsExplanation();
            angleChanged = true;
        });

        angleRange.addEventListener('change', function() {
            if (angleChanged) {
                // Explicación física del ángulo
                const angleRad = angle * Math.PI / 180;
                const gravitationalForce = mass * gravity * Math.sin(angleRad);
                const normalForce = mass * gravity * Math.cos(angleRad);
                const frictionForce = friction * normalForce;
                const netForceValue = gravitationalForce - frictionForce;
               
                if (netForceValue <= 0 && angle < 90) {
                    showNotification('Objeto en Reposo', `El objeto no se mueve porque la fuerza de fricción (${frictionForce.toFixed(2)} N) es mayor o igual que la componente gravitatoria paralela (${gravitationalForce.toFixed(2)} N). Aumente el ángulo o reduzca la fricción.`, 'warning');
                } else {
                    showNotification('Ángulo Modificado', `El ángulo del plano se ha cambiado a ${this.value}°. Esto afecta la componente gravitatoria paralela al plano.`, 'info');
                }
                angleChanged = false;
            }
        });
       
        frictionRange.addEventListener('input', function() {
            frictionValue.textContent = parseFloat(this.value).toFixed(2);
            frictionInput.value = this.value;
            friction = parseFloat(this.value);
            updateResultsExplanation();
            frictionChanged = true;
        });

        frictionRange.addEventListener('change', function() {
            if (frictionChanged) {
                // Explicación física de la fricción
                const angleRad = angle * Math.PI / 180;
                const gravitationalForce = mass * gravity * Math.sin(angleRad);
                const normalForce = mass * gravity * Math.cos(angleRad);
                const frictionForce = friction * normalForce;
                const netForceValue = gravitationalForce - frictionForce;
               
                if (netForceValue <= 0) {
                    showNotification('Objeto en Reposo', `El objeto no se mueve porque la fuerza de fricción (${frictionForce.toFixed(2)} N) es mayor o igual que la componente gravitatoria paralela (${gravitationalForce.toFixed(2)} N). Reduzca la fricción o aumente el ángulo.`, 'warning');
                } else {
                    showNotification('Fricción Modificada', `El coeficiente de fricción se ha cambiado a ${parseFloat(this.value).toFixed(2)}. Esto afecta la fuerza de fricción que se opone al movimiento.`, 'info');
                }
                frictionChanged = false;
            }
        });
       
        // Sincronización para la pestaña de poleas - MODIFICADO para notificar solo al soltar
        angleRangePulley.addEventListener('input', function() {
            angleValuePulley.textContent = this.value + '°';
            angleInputPulley.value = this.value;
            angle = parseFloat(this.value);
            drawSimulation();
            if (isRunning) {
                resetSimulation();
            }
            updateResultsExplanation();
            angleChanged = true;
        });

        angleRangePulley.addEventListener('change', function() {
            if (angleChanged) {
                // Explicación física del ángulo con poleas
                const angleRad = angle * Math.PI / 180;
                const gravitationalForce = mass * gravity * Math.sin(angleRad);
                const normalForce = mass * gravity * Math.cos(angleRad);
                const frictionForce = friction * normalForce;
                const counterWeightForce = pulleyConfig.counterMass * gravity;
               
                let netForceValue = gravitationalForce - frictionForce - counterWeightForce;
               
                if (netForceValue <= 0) {
                    showNotification('Objeto en Reposo', `El objeto no se mueve porque la fuerza del contrapeso y la fricción superan la componente gravitatoria. Aumente el ángulo, reduzca la fricción o ajuste el contrapeso.`, 'warning');
                } else {
                    showNotification('Ángulo Modificado', `El ángulo del plano se ha cambiado a ${this.value}°. Esto afecta la componente gravitatoria paralela al plano.`, 'info');
                }
                angleChanged = false;
            }
        });
       
        frictionRangePulley.addEventListener('input', function() {
            frictionValuePulley.textContent = parseFloat(this.value).toFixed(2);
            frictionInputPulley.value = this.value;
            friction = parseFloat(this.value);
            updateResultsExplanation();
            frictionChanged = true;
        });

        frictionRangePulley.addEventListener('change', function() {
            if (frictionChanged) {
                // Explicación física de la fricción con poleas
                const angleRad = angle * Math.PI / 180;
                const gravitationalForce = mass * gravity * Math.sin(angleRad);
                const normalForce = mass * gravity * Math.cos(angleRad);
                const frictionForce = friction * normalForce;
                const counterWeightForce = pulleyConfig.counterMass * gravity;
               
                let netForceValue = gravitationalForce - frictionForce - counterWeightForce;
               
                if (netForceValue <= 0) {
                    showNotification('Objeto en Reposo', `El objeto no se mueve porque la fuerza de fricción (${frictionForce.toFixed(2)} N) junto con el contrapeso superan la componente gravitatoria. Reduzca la fricción o ajuste el contrapeso.`, 'warning');
                } else {
                    showNotification('Fricción Modificada', `El coeficiente de fricción se ha cambiado a ${parseFloat(this.value).toFixed(2)}. Esto afecta la fuerza de fricción que se opone al movimiento.`, 'info');
                }
                frictionChanged = false;
            }
        });
       
        // Validación de parámetros
        function validateParameters() {
            let isValid = true;
           
            // Validar masa
            if (mass <= 0) {
                massValidation.textContent = "La masa debe ser mayor que cero";
                massValidation.style.display = 'block';
                isValid = false;
                showNotification('Error de Validación', 'La masa debe ser mayor que cero.', 'error');
            } else {
                massValidation.style.display = 'none';
            }
           
            // Validar contrapeso si las poleas están activadas
            if (usePulley && pulleyConfig.counterMass <= 0) {
                counterMassValidation.textContent = "La masa del contrapeso debe ser mayor que cero";
                counterMassValidation.style.display = 'block';
                isValid = false;
                showNotification('Error de Validación', 'La masa del contrapeso debe ser mayor que cero.', 'error');
            } else {
                counterMassValidation.style.display = 'none';
            }
           
            return isValid;
        }
       
        // Actualizar valores de los inputs - MODIFICADO para notificar solo al cambiar
        massInput.addEventListener('change', function() {
            let value = parseFloat(this.value);
            if (value < 0.1) value = 0.1;
            this.value = value;
            mass = value;
            validateParameters();
            if (isRunning) {
                resetSimulation();
            }
            updateResultsExplanation();
           
            // Explicación física de la masa
            const angleRad = angle * Math.PI / 180;
            const gravitationalForce = mass * gravity * Math.sin(angleRad);
            const normalForce = mass * gravity * Math.cos(angleRad);
            const frictionForce = friction * normalForce;
            const netForceValue = gravitationalForce - frictionForce;
           
            if (netForceValue <= 0) {
                showNotification('Objeto en Reposo', `El objeto no se mueve porque la fuerza de fricción supera la componente gravitatoria. La masa afecta ambas fuerzas por igual, por lo que no cambia el equilibrio.`, 'warning');
            } else {
                showNotification('Masa Modificada', `La masa del objeto se ha cambiado a ${value} kg. Esto afecta tanto la fuerza gravitatoria como la inercia del objeto.`, 'info');
            }
        });
       
        angleInput.addEventListener('change', function() {
            let value = parseFloat(this.value);
            if (value < 5) value = 5;
            if (value > 60) value = 60;
            this.value = value;
            angleRange.value = value;
            angleValue.textContent = value + '°';
            angle = value;
            drawSimulation();
            if (isRunning) {
                resetSimulation();
            }
            updateResultsExplanation();
            showNotification('Ángulo Modificado', `El ángulo del plano se ha cambiado a ${value}°. Esto afecta la componente gravitatoria paralela al plano.`, 'info');
        });
       
        frictionInput.addEventListener('change', function() {
            let value = parseFloat(this.value);
            if (value < 0) value = 0;
            if (value > 0.5) value = 0.5;
            this.value = value;
            frictionRange.value = value;
            frictionValue.textContent = value.toFixed(2);
            friction = value;
            updateResultsExplanation();
            showNotification('Fricción Modificada', `El coeficiente de fricción se ha cambiado a ${value.toFixed(2)}. Esto afecta la fuerza de fricción que se opone al movimiento.`, 'info');
        });
       
        lengthInput.addEventListener('change', function() {
            let value = parseFloat(this.value);
            if (value < 1) value = 1;
            this.value = value;
            length = value;
            drawSimulation();
            if (isRunning) {
                resetSimulation();
            }
            showNotification('Longitud Modificada', `La longitud del plano se ha cambiado a ${value} m. Esto afecta la distancia que recorrerá el objeto.`, 'info');
        });
       
        gravityInput.addEventListener('change', function() {
            let value = parseFloat(this.value);
            if (value < 1) value = 1;
            this.value = value;
            gravity = value;
            updateResultsExplanation();
            showNotification('Gravedad Modificada', `El valor de la gravedad se ha cambiado a ${value} m/s². Esto afecta todas las fuerzas gravitatorias en el sistema.`, 'info');
        });
       
        // Actualizar valores de los inputs de la pestaña de poleas - MODIFICADO para notificar solo al cambiar
        massInputPulley.addEventListener('change', function() {
            let value = parseFloat(this.value);
            if (value < 0.1) value = 0.1;
            this.value = value;
            mass = value;
            validateParameters();
            if (isRunning) {
                resetSimulation();
            }
            updateResultsExplanation();
           
            // Explicación física de la masa con poleas
            const angleRad = angle * Math.PI / 180;
            const gravitationalForce = mass * gravity * Math.sin(angleRad);
            const normalForce = mass * gravity * Math.cos(angleRad);
            const frictionForce = friction * normalForce;
            const counterWeightForce = pulleyConfig.counterMass * gravity;
           
            let netForceValue = gravitationalForce - frictionForce - counterWeightForce;
           
            if (netForceValue <= 0) {
                showNotification('Objeto en Reposo', `El objeto no se mueve porque el contrapeso y la fricción superan la componente gravitatoria. Aumente la masa del objeto o reduzca el contrapeso.`, 'warning');
            } else {
                showNotification('Masa Modificada', `La masa del objeto se ha cambiado a ${value} kg. Esto afecta tanto la fuerza gravitatoria como la inercia del objeto.`, 'info');
            }
        });
       
        angleInputPulley.addEventListener('change', function() {
            let value = parseFloat(this.value);
            if (value < 5) value = 5;
            if (value > 60) value = 60;
            this.value = value;
            angleRangePulley.value = value;
            angleValuePulley.textContent = value + '°';
            angle = value;
            drawSimulation();
            if (isRunning) {
                resetSimulation();
            }
            updateResultsExplanation();
            showNotification('Ángulo Modificado', `El ángulo del plano se ha cambiado a ${value}°. Esto afecta la componente gravitatoria paralela al plano.`, 'info');
        });
       
        frictionInputPulley.addEventListener('change', function() {
            let value = parseFloat(this.value);
            if (value < 0) value = 0;
            if (value > 0.5) value = 0.5;
            this.value = value;
            frictionRangePulley.value = value;
            frictionValuePulley.textContent = value.toFixed(2);
            friction = value;
            updateResultsExplanation();
            showNotification('Fricción Modificada', `El coeficiente de fricción se ha cambiado a ${value.toFixed(2)}. Esto afecta la fuerza de fricción que se opone al movimiento.`, 'info');
        });
       
        lengthInputPulley.addEventListener('change', function() {
            let value = parseFloat(this.value);
            if (value < 1) value = 1;
            this.value = value;
            length = value;
            drawSimulation();
            if (isRunning) {
                resetSimulation();
            }
            showNotification('Longitud Modificada', `La longitud del plano se ha cambiado a ${value} m. Esto afecta la distancia que recorrerá el objeto.`, 'info');
        });
       
        gravityInputPulley.addEventListener('change', function() {
            let value = parseFloat(this.value);
            if (value < 1) value = 1;
            this.value = value;
            gravity = value;
            updateResultsExplanation();
            showNotification('Gravedad Modificada', `El valor de la gravedad se ha cambiado a ${value} m/s². Esto afecta todas las fuerzas gravitatorias en el sistema.`, 'info');
        });
       
        // Configuración de poleas - MODIFICADO para notificar solo al cambiar
        counterMassInput.addEventListener('change', function() {
            let value = parseFloat(this.value);
            if (value < 0.1) value = 0.1;
            this.value = value;
            pulleyConfig.counterMass = value;
            validateParameters();
            if (isRunning) {
                resetSimulation();
            }
            updateResultsExplanation();
           
            // Explicación física del contrapeso
            const angleRad = angle * Math.PI / 180;
            const gravitationalForce = mass * gravity * Math.sin(angleRad);
            const normalForce = mass * gravity * Math.cos(angleRad);
            const frictionForce = friction * normalForce;
            const counterWeightForce = pulleyConfig.counterMass * gravity;
           
            let netForceValue = gravitationalForce - frictionForce - counterWeightForce;
           
            if (netForceValue <= 0) {
                showNotification('Objeto en Reposo', `El objeto no se mueve porque el contrapeso de ${value} kg es demasiado pesado. Reduzca la masa del contrapeso para permitir el movimiento.`, 'warning');
            } else {
                showNotification('Contrapeso Modificado', `La masa del contrapeso se ha cambiado a ${value} kg. Esto afecta la fuerza que contrarresta el movimiento del objeto.`, 'info');
            }
        });
       
        // Función drawSimulation - CORREGIDA para mostrar la masa correctamente
        function drawSimulation() {
            const width = canvas.width;
            const height = canvas.height;
           
            // Calcular dimensiones del plano
            const angleRad = angle * Math.PI / 180;
            const planeHeight = Math.min(height * 0.5, width * 0.6 * Math.tan(angleRad));
            const planeWidth = planeHeight / Math.tan(angleRad);
           
            // Ajustar posición inicial del plano según si hay polea o no
            const baseX = usePulley ? width * 0.4 : width * 0.2;
            const baseY = height - 100;
           
            // Calcular posición del objeto
            const objectX = baseX + (position / length) * planeWidth;
            const objectY = baseY - planeHeight + (position / length) * planeHeight;
           
            ctx.clearRect(0, 0, width, height);
           
            // Dibujar plano inclinado
            ctx.beginPath();
            ctx.moveTo(baseX, baseY);
            ctx.lineTo(baseX + planeWidth, baseY);
            ctx.lineTo(baseX, baseY - planeHeight);
            ctx.closePath();
            ctx.fillStyle = "#a3c9a8";
            ctx.fill();
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 2;
            ctx.stroke();
           
            // Dibujar poleas si están activadas
            if (usePulley) {
                drawPulleySystem(width, height, baseX, baseY, planeWidth, planeHeight, objectX, objectY);
            }
           
            // --- DIBUJO DE LA MASA (Sistema de coordenadas ROTADO) ---
           
            ctx.save();
            // 1. Mover el origen al punto de inicio del plano inclinado (Vértice Superior Izquierdo, V1)
            const inclineXStart = baseX;
            const inclineYStart = baseY - planeHeight;
            ctx.translate(inclineXStart, inclineYStart);
            // 2. Rotar el canvas para alinear el eje X con la hipotenusa (incline)
            ctx.rotate(angleRad);
           
            // Posición a lo largo del plano inclinado (eje X rotado)
            // Posición de dibujo para que position=0 esté en el BOTTOM RIGHT y position=length esté en el TOP LEFT
            const inclineLengthCanvas = planeWidth / Math.cos(angleRad); // Longitud de la hipotenusa en píxeles
            const distanceMovedFromTop = (position / length) * inclineLengthCanvas;
            const massDrawX = inclineLengthCanvas - distanceMovedFromTop - 40; // 40 es el ancho del bloque
            const massDrawY = 0; // El plano inclinado es ahora el eje X
           
            // 1. Dibuja el cuerpo (rectángulo)
            const massWidth = 40;
            const massHeight = 25;
            ctx.fillStyle = "rgba(211, 211, 211, 0.9)"; // Gris claro
            ctx.strokeStyle = "#333"; // Gris oscuro para el borde
            ctx.lineWidth = 1.5;
           
            // Dibuja el rectángulo desde la esquina superior izquierda (ajustado para sentarse en el eje X)
            ctx.fillRect(massDrawX, massDrawY - massHeight, massWidth, massHeight);
            ctx.strokeRect(massDrawX, massDrawY - massHeight, massWidth, massHeight);
           
            // 2. Dibuja el centro de masa (círculo rojo)
            const massCenterX = massDrawX + massWidth / 2;
            const massCenterY = massDrawY - massHeight / 2; // Centro vertical
           
            ctx.beginPath();
            ctx.arc(massCenterX, massCenterY, 3.5, 0, 2 * Math.PI); // Radio de 3.5px para el punto
            ctx.fillStyle = "#e53e3e"; // Rojo
            ctx.fill();
            ctx.strokeStyle = '#000'; // Pequeño borde negro para contraste
            ctx.lineWidth = 0.5;
            ctx.stroke();
           
            ctx.restore();
            // --- FIN DIBUJO DE LA MASA ---
           
            // Etiqueta de masa
            ctx.fillStyle = '#000';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`${mass} kg`, objectX, objectY - massHeight - 15);
           
            // Posición del ángulo (esquina inferior DERECHA)
            const angleArcRadius = 30; // Radio del arco, reducido para que quepa mejor.
            const angleArcX = baseX + planeWidth; // La X del vértice (extremo derecho de la base)
            const angleArcY = baseY;              // La Y del vértice (la base horizontal)
                       
            // Arco para θ
            ctx.beginPath();
            // El ángulo se mide desde la base (Math.PI) hacia la hipotenusa (Math.PI - angleRad).
            // Dibuja el arco desde Math.PI - angleRad hasta Math.PI (sentido antihorario = false)
            ctx.arc(angleArcX, angleArcY, angleArcRadius, Math.PI - angleRad, Math.PI, false);
            ctx.strokeStyle = '#e74c3c';
            ctx.lineWidth = 2;
            ctx.stroke();
                       
            // Etiqueta θ DENTRO del arco
            ctx.fillStyle = '#e74c3c';
            ctx.font = 'bold 18px Arial';
           
            // Calcular posición para el texto θ (a la mitad del ángulo y más cerca del vértice)
            const thetaTextRadius = angleArcRadius * 0.6; // Mueve el texto más adentro del arco
           
            // Ángulo para el centro del texto: Math.PI - angleRad / 2
            const centerAngle = Math.PI - angleRad / 2;
           
            const thetaX = angleArcX + thetaTextRadius * Math.cos(centerAngle);
            const thetaY = angleArcY + thetaTextRadius * Math.sin(centerAngle);
           
            ctx.fillText('θ', thetaX, thetaY);
           
            // Dibujar cuadrado de 90° en la base (entre cateto adyacente y opuesto)
            const squareSize = 15;
            const squareX = baseX + squareSize/2;
            const squareY = baseY - squareSize/2;
           
            ctx.beginPath();
            ctx.moveTo(squareX - squareSize/2, squareY - squareSize/2);
            ctx.lineTo(squareX + squareSize/2, squareY - squareSize/2);
            ctx.lineTo(squareX + squareSize/2, squareY + squareSize/2);
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 2;
            ctx.stroke();
        }
       
        // Dibujar sistema de poleas mejorado con cuerda recta
        function drawPulleySystem(width, height, baseX, baseY, planeWidth, planeHeight, objectX, objectY) {
            // Posicionar la polea a la izquierda del plano
            const pulleyX = baseX - 100;
            const pulleyY = baseY - planeHeight - 50;
            const pulleyRadius = 25;
           
            // Dibujar soporte de la polea
            ctx.beginPath();
            ctx.moveTo(pulleyX - 40, pulleyY - 50);
            ctx.lineTo(pulleyX + 40, pulleyY - 50);
            ctx.lineTo(pulleyX + 40, pulleyY - 20);
            ctx.lineTo(pulleyX - 40, pulleyY - 20);
            ctx.closePath();
            ctx.fillStyle = '#7f8c8d';
            ctx.fill();
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 2;
            ctx.stroke();
           
            // Detalles del soporte
            ctx.beginPath();
            ctx.moveTo(pulleyX - 35, pulleyY - 45);
            ctx.lineTo(pulleyX + 35, pulleyY - 45);
            ctx.strokeStyle = '#95a5a6';
            ctx.lineWidth = 1;
            ctx.stroke();
           
            // Dibujar polea
            ctx.beginPath();
            ctx.arc(pulleyX, pulleyY, pulleyRadius, 0, Math.PI * 2);
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 4;
            ctx.stroke();
           
            // Detalles internos de la polea
            ctx.beginPath();
            ctx.arc(pulleyX, pulleyY, pulleyRadius - 8, 0, Math.PI * 2);
            ctx.strokeStyle = '#95a5a6';
            ctx.lineWidth = 2;
            ctx.stroke();
           
            // Eje de la polea
            ctx.beginPath();
            ctx.arc(pulleyX, pulleyY, 4, 0, Math.PI * 2);
            ctx.fillStyle = '#e74c3c';
            ctx.fill();
           
            // Dibujar cuerda desde el objeto hasta la polea (RECTA)
            ctx.beginPath();
            ctx.moveTo(objectX, objectY);
            ctx.lineTo(pulleyX, pulleyY);
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 3;
            ctx.stroke();
           
            // Calcular posición del contrapeso (se mueve en dirección opuesta al objeto)
            const maxCounterWeightMovement = 200;
            const counterWeightY = pulleyY + pulleyRadius + 30 + (position / length) * maxCounterWeightMovement;
           
            // Dibujar contrapeso como RECTÁNGULO
            const counterWeightWidth = 20 + pulleyConfig.counterMass / 2;
            const counterWeightHeight = 15 + pulleyConfig.counterMass / 3;
            ctx.fillStyle = '#3498db';
            ctx.fillRect(pulleyX - counterWeightWidth/2, counterWeightY - counterWeightHeight/2, counterWeightWidth, counterWeightHeight);
            ctx.strokeStyle = '#2980b9';
            ctx.lineWidth = 2;
            ctx.strokeRect(pulleyX - counterWeightWidth/2, counterWeightY - counterWeightHeight/2, counterWeightWidth, counterWeightHeight);
           
            // Detalles del contrapeso
            ctx.fillStyle = '#2980b9';
            ctx.fillRect(pulleyX - counterWeightWidth/2 + 5, counterWeightY - counterWeightHeight/2 + 5, counterWeightWidth - 10, 3);
            ctx.fillRect(pulleyX - counterWeightWidth/2 + 5, counterWeightY - counterWeightHeight/2 + 10, counterWeightWidth - 10, 3);
           
            // Etiqueta de contrapeso
            ctx.fillStyle = '#2c3e50';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`${pulleyConfig.counterMass} kg`, pulleyX, counterWeightY + counterWeightHeight/2 + 20);
           
            // Dibujar cuerda del contrapeso (RECTA)
            ctx.beginPath();
            ctx.moveTo(pulleyX, pulleyY);
            ctx.lineTo(pulleyX, counterWeightY - counterWeightHeight/2);
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 3;
            ctx.stroke();
        }
       
        // Calcular física del plano inclinado - CORREGIDA para funcionamiento correcto
        function calculatePhysics() {
            const angleRad = angle * Math.PI / 180;
           
            // Fuerza gravitatoria paralela al plano
            const gravitationalForce = mass * gravity * Math.sin(angleRad);
           
            // Fuerza normal
            const normalForce = mass * gravity * Math.cos(angleRad);
           
            // Fuerza de fricción
            const frictionForce = friction * normalForce;
           
            // Fuerza neta inicial
            let netForceValue = gravitationalForce - frictionForce;
           
            // Aplicar sistema de poleas si está activado
            if (usePulley) {
                const counterWeightForce = pulleyConfig.counterMass * gravity;
               
                // Sistema de polea simple: cambia dirección pero no magnitud de la fuerza
                // La tensión en la cuerda afecta a ambos lados
                // Para el objeto en el plano: Fuerza neta = Fgravitatoria - Ffricción - Tensión
                // Para el contrapeso: Fuerza neta = Tensión - Fgravitatoria del contrapeso
                // Resolviendo el sistema:
                const totalMass = mass + pulleyConfig.counterMass;
                netForceValue = gravitationalForce - frictionForce - counterWeightForce;
               
                // La aceleración es la misma para ambos objetos
                acceleration = netForceValue / totalMass;
            } else {
                // Sin polea: aceleración simple
                acceleration = netForceValue / mass;
            }
           
            // Si la aceleración es muy pequeña o negativa cuando debería ser positiva, ajustar
            if (Math.abs(acceleration) < 0.01) {
                acceleration = 0;
            }
           
            // Actualizar velocidad y posición
            const deltaTime = 0.016; // Aproximadamente 60 FPS
           
            if (isRunning && !isPaused) {
                velocity += acceleration * deltaTime;
               
                // No permitir velocidad negativa si el objeto está en la parte superior
                if (position <= 0 && velocity < 0) {
                    velocity = 0;
                    position = 0;
                }
               
                // No permitir que el objeto sobrepase la longitud del plano
                if (position >= length && velocity > 0) {
                    velocity = 0;
                    position = length;
                    isRunning = false;
                    showNotification('Simulación Completada', 'El objeto ha llegado al final del plano inclinado.', 'success');
                } else {
                    position += velocity * deltaTime;
                }
               
                currentTime += deltaTime;
            }
           
            // Calcular energía
            const heightFromTop = (length - position) * Math.sin(angleRad);
            const potentialEnergy = mass * gravity * heightFromTop;
            const kineticEnergy = 0.5 * mass * velocity * velocity;
            energy = potentialEnergy + kineticEnergy;
           
            netForce = netForceValue;
           
            // Actualizar valores en pantalla
            timeValue.textContent = currentTime.toFixed(2) + " s";
            positionValue.textContent = position.toFixed(2) + " M";
            velocityValue.textContent = velocity.toFixed(2) + " M/s";
            accelerationValue.textContent = acceleration.toFixed(2) + " M/s²";
            forceValue.textContent = netForce.toFixed(2) + " N";
            energyValue.textContent = energy.toFixed(2) + " J";
           
            // Actualizar explicación de resultados
            updateResultsExplanation();
           
            // Guardar datos para exportación
            if (isRunning && !isPaused) {
                simulationData.push({
                    time: currentTime,
                    position: position,
                    velocity: velocity,
                    acceleration: acceleration,
                    force: netForce,
                    energy: energy
                });
            }
        }
       
        // Bucle de animación
        function animate() {
            calculatePhysics();
            drawSimulation();
            if (isRunning && !isPaused) {
                animationId = requestAnimationFrame(animate);
            }
        }
       
        // Función para reiniciar simulación
        function resetSimulation() {
            isRunning = false;
            isPaused = false;
            currentTime = 0;
            position = 0;
            velocity = 0;
            acceleration = 0;
            netForce = 0;
            energy = 0;
            simulationData = [];
           
            timeValue.textContent = "0.00 s";
            positionValue.textContent = "0.00 M";
            velocityValue.textContent = "0.00 M/s";
            accelerationValue.textContent = "0.00 M/s²";
            forceValue.textContent = "0.00 N";
            energyValue.textContent = "0.00 J";
           
            drawSimulation();
            updateResultsExplanation();
            showNotification('Simulación Reiniciada', 'La simulación se ha reiniciado a su estado inicial.', 'info');
        }
       
        // Función para exportar datos a Excel mejorada
        function exportData() {
            if (simulationData.length === 0) {
                showNotification('Sin Datos', 'No hay datos para exportar. Ejecuta la simulación primero.', 'warning');
                return;
            }

            // Crear contenido CSV estructurado
            let csvContent = "";
           
            // Encabezado con información del experimento
            csvContent += "LABORATORIO VIRTUAL - PLANO INCLINADO\n";
            csvContent += "Resultados de Simulación\n\n";
           
            // Información de configuración
            csvContent += "CONFIGURACIÓN DEL EXPERIMENTO\n";
            csvContent += `Masa del objeto: ${mass} kg\n`;
            csvContent += `Ángulo del plano: ${angle}°\n`;
            csvContent += `Coeficiente de fricción: ${friction}\n`;
            csvContent += `Longitud del plano: ${length} m\n`;
            csvContent += `Gravedad: ${gravity} m/s²\n`;
            csvContent += `Sistema de poleas: ${usePulley ? "Activado" : "Desactivado"}\n`;
            if (usePulley) {
                csvContent += `Masa del contrapeso: ${pulleyConfig.counterMass} kg\n`;
            }
            csvContent += `Fecha de simulación: ${new Date().toLocaleString()}\n\n`;
           
            // Resumen de resultados
            csvContent += "RESUMEN DE RESULTADOS\n";
            const finalTime = simulationData[simulationData.length - 1].time;
            const finalPosition = simulationData[simulationData.length - 1].position;
            const maxVelocity = Math.max(...simulationData.map(d => Math.abs(d.velocity)));
            const maxAcceleration = Math.max(...simulationData.map(d => Math.abs(d.acceleration)));
           
            csvContent += `Tiempo total de simulación: ${finalTime.toFixed(2)} s\n`;
            csvContent += `Distancia recorrida: ${finalPosition.toFixed(2)} m\n`;
            csvContent += `Velocidad máxima: ${maxVelocity.toFixed(2)} m/s\n`;
            csvContent += `Aceleración máxima: ${maxAcceleration.toFixed(2)} m/s²\n`;
            csvContent += `Estado final: ${finalPosition >= length ? "Completado" : "En progreso"}\n\n`;
           
            // Datos detallados
            csvContent += "DATOS DETALLADOS DE LA SIMULACIÓN\n";
            csvContent += "Tiempo (s),Posición (m),Velocidad (m/s),Aceleración (m/s²),Fuerza Neta (N),Energía (J)\n";
           
            simulationData.forEach(data => {
                csvContent += `${data.time.toFixed(3)},${data.position.toFixed(3)},${data.velocity.toFixed(3)},${data.acceleration.toFixed(3)},${data.force.toFixed(3)},${data.energy.toFixed(3)}\n`;
            });
           
            // Crear y descargar archivo
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.setAttribute("href", url);
            link.setAttribute("download", `simulacion_plano_inclinado_${new Date().toISOString().slice(0,10)}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
           
            showNotification('Datos Exportados', 'Los datos de la simulación se han exportado correctamente a un archivo CSV estructurado.', 'success');
        }

        // Función para exportar datos a Excel (XLSX) usando SheetJS
        function exportToExcel() {
            if (simulationData.length === 0) {
                showNotification('Sin Datos', 'No hay datos para exportar. Ejecuta la simulación primero.', 'warning');
                return;
            }

            // Verificar si SheetJS está disponible
            if (typeof XLSX === 'undefined') {
                showNotification('Error', 'La funcionalidad de exportación a Excel requiere la biblioteca SheetJS. Exportando como CSV en su lugar.', 'error');
                exportData();
                return;
            }

            try {
                // Crear un nuevo libro de trabajo
                const wb = XLSX.utils.book_new();
               
                // Hoja de configuración
                const configData = [
                    ["LABORATORIO VIRTUAL - PLANO INCLINADO"],
                    ["Resultados de Simulación"],
                    [""],
                    ["CONFIGURACIÓN DEL EXPERIMENTO"],
                    ["Masa del objeto:", mass, "kg"],
                    ["Ángulo del plano:", angle, "°"],
                    ["Coeficiente de fricción:", friction, ""],
                    ["Longitud del plano:", length, "m"],
                    ["Gravedad:", gravity, "m/s²"],
                    ["Sistema de poleas:", usePulley ? "Activado" : "Desactivado", ""],
                    ...(usePulley ? [["Masa del contrapeso:", pulleyConfig.counterMass, "kg"]] : []),
                    ["Fecha de simulación:", new Date().toLocaleString(), ""],
                    [""]
                ];
               
                const configWs = XLSX.utils.aoa_to_sheet(configData);
                XLSX.utils.book_append_sheet(wb, configWs, "Configuración");
               
                // Hoja de resumen
                const finalTime = simulationData[simulationData.length - 1].time;
                const finalPosition = simulationData[simulationData.length - 1].position;
                const maxVelocity = Math.max(...simulationData.map(d => Math.abs(d.velocity)));
                const maxAcceleration = Math.max(...simulationData.map(d => Math.abs(d.acceleration)));
               
                const summaryData = [
                    ["RESUMEN DE RESULTADOS"],
                    ["Tiempo total de simulación:", finalTime.toFixed(2), "s"],
                    ["Distancia recorrida:", finalPosition.toFixed(2), "m"],
                    ["Velocidad máxima:", maxVelocity.toFixed(2), "m/s"],
                    ["Aceleración máxima:", maxAcceleration.toFixed(2), "m/s²"],
                    ["Estado final:", finalPosition >= length ? "Completado" : "En progreso", ""],
                    [""],
                    ["ANÁLISIS FÍSICO"],
                    ["Fuerza gravitatoria paralela:", (mass * gravity * Math.sin(angle * Math.PI / 180)).toFixed(2), "N"],
                    ["Fuerza normal:", (mass * gravity * Math.cos(angle * Math.PI / 180)).toFixed(2), "N"],
                    ["Fuerza de fricción:", (friction * mass * gravity * Math.cos(angle * Math.PI / 180)).toFixed(2), "N"],
                    ...(usePulley ? [["Fuerza del contrapeso:", (pulleyConfig.counterMass * gravity).toFixed(2), "N"]] : []),
                    ["Fuerza neta inicial:", simulationData[0]?.force.toFixed(2) || "0.00", "N"]
                ];
               
                const summaryWs = XLSX.utils.aoa_to_sheet(summaryData);
                XLSX.utils.book_append_sheet(wb, summaryWs, "Resumen");
               
                // Hoja de datos detallados
                const headers = ["Tiempo (s)", "Posición (m)", "Velocidad (m/s)", "Aceleración (m/s²)", "Fuerza Neta (N)", "Energía (J)"];
                const detailedData = simulationData.map(data => [
                    data.time,
                    data.position,
                    data.velocity,
                    data.acceleration,
                    data.force,
                    data.energy
                ]);
               
                detailedData.unshift(headers);
                const detailedWs = XLSX.utils.aoa_to_sheet(detailedData);
                XLSX.utils.book_append_sheet(wb, detailedWs, "Datos Detallados");
               
                // Generar y descargar archivo
                XLSX.writeFile(wb, `simulacion_plano_inclinado_${new Date().toISOString().slice(0,10)}.xlsx`);
               
                showNotification('Excel Exportado', 'Los datos se han exportado correctamente a un archivo Excel con varias hojas.', 'success');
            } catch (error) {
                console.error('Error al exportar a Excel:', error);
                showNotification('Error', 'No se pudo exportar a Excel. Exportando como CSV en su lugar.', 'error');
                exportData();
            }
        }

        // Controladores de botones
        startBtn.addEventListener('click', function() {
            if (!validateParameters()) return;
           
            if (!isRunning) {
                isRunning = true;
                isPaused = false;
                pauseBtn.textContent = "Pausar";
                // Reiniciar datos al iniciar nueva simulación
                if (currentTime === 0) {
                    simulationData = [];
                }
                animate();
                showNotification('Simulación Iniciada', 'La simulación ha comenzado. El objeto se moverá según las fuerzas aplicadas.', 'success');
            } else if (isPaused) {
                isPaused = false;
                pauseBtn.textContent = "Pausar";
                animate();
                showNotification('Simulación Reanudada', 'La simulación ha sido reanudada.', 'info');
            }
        });
       
        pauseBtn.addEventListener('click', function() {
            if (isRunning) {
                isPaused = !isPaused;
                pauseBtn.textContent = isPaused ? "Continuar" : "Pausar";
                if (!isPaused) {
                    animate();
                    showNotification('Simulación Reanudada', 'La simulación ha sido reanudada.', 'info');
                } else {
                    showNotification('Simulación Pausada', 'La simulación ha sido pausada.', 'info');
                }
            }
        });
       
        resetBtn.addEventListener('click', function() {
            resetSimulation();
        });
       
        // Actualizar el botón de exportación para usar la nueva función
        exportBtn.addEventListener('click', function() {
            // Verificar si SheetJS está disponible para ofrecer ambas opciones
            if (typeof XLSX !== 'undefined') {
                // Crear un menú desplegable para elegir el formato
                const exportMenu = document.createElement('div');
                exportMenu.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: white;
                    padding: 20px;
                    border-radius: 10px;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                    z-index: 1000;
                    min-width: 250px;
                `;
               
                exportMenu.innerHTML = `
                    <h3 style="margin-bottom: 15px; color: var(--primary-color);">Exportar Datos</h3>
                    <p style="margin-bottom: 15px; color: var(--secondary-color);">Seleccione el formato de exportación:</p>
                    <button id="excel-export" style="background: var(--success-color); margin-bottom: 10px; width: 100%; padding: 10px; border: none; border-radius: 5px; color: white; cursor: pointer;">Excel (.xlsx)</button>
                    <button id="csv-export" style="background: var(--accent-color); width: 100%; padding: 10px; border: none; border-radius: 5px; color: white; cursor: pointer;">CSV (.csv)</button>
                    <button id="cancel-export" style="background: var(--danger-color); margin-top: 10px; width: 100%; padding: 10px; border: none; border-radius: 5px; color: white; cursor: pointer;">Cancelar</button>
                `;
               
                document.body.appendChild(exportMenu);
               
                // Event listeners para los botones
                document.getElementById('excel-export').addEventListener('click', function() {
                    document.body.removeChild(exportMenu);
                    exportToExcel();
                });
               
                document.getElementById('csv-export').addEventListener('click', function() {
                    document.body.removeChild(exportMenu);
                    exportData();
                });
               
                document.getElementById('cancel-export').addEventListener('click', function() {
                    document.body.removeChild(exportMenu);
                });
            } else {
                // Si SheetJS no está disponible, usar CSV por defecto
                exportData();
            }
        });
       
        // Inicialización
        window.addEventListener('load', function() {
            setupCanvas();
            drawSimulation();
            updateResultsExplanation();
            showNotification('Bienvenido', 'El laboratorio virtual de plano inclinado está listo. Configure los parámetros y presione "Iniciar Simulación".', 'info');
        });
       
        window.addEventListener('resize', function() {
            setupCanvas();
            drawSimulation();
        });
    </script>
</body>
</html>
